namespace Spice86.Emulator.CPU;

using Serilog;

using Spice86.Emulator.Callback;
using Spice86.Emulator.Errors;
using Spice86.Emulator.Function;
using Spice86.Emulator.IOPorts;
using Spice86.Emulator.Memory;
using Spice86.Emulator.VM;
using Spice86.Utils;

using System;
using System.Collections.Generic;

/// <summary>
/// Implementation of a 8086 CPU. <br /> It has some 80186, 80286 and 80386 instructions as some
/// program use them. <br /> It also has some x87 FPU instructions to support telling the programs
/// that x87 is not supported :) <br /> Some docs that helped the implementation: <ul> <li>
/// Instructions decoding: http://rubbermallet.org/8086%20notes.pdf and
/// http://ref.x86asm.net/coder32.html </li><li> Instructions implementation details:
/// https://www.felixcloutier.com/x86/ </li><li> Pure 8086 instructions:
/// https://jbwyatt.com/253/emu/8086_instruction_set.html </li></ul>
/// </summary>
public class Cpu {

    // Extract regIndex from opcode
    private const int RegIndexMask = 0b111;

    private static readonly ILogger _logger = Log.Logger.ForContext<Cpu>();
    private static readonly HashSet<int> _stringOpCodes = new() { 0xA4, 0xA5, 0xA6, 0xA7, 0xAA, 0xAB, 0xAC, 0xAD, 0xAE, 0xAF, 0x6C, 0x6D, 0x6E, 0x6F };

    private readonly Alu _alu;
    private readonly FunctionHandler _functionHandler;
    private readonly FunctionHandler _functionHandlerInExternalInterrupt;
    private readonly Machine _machine;
    private readonly Memory _memory;
    private readonly ModRM _modRM;
    private readonly Stack _stack;
    private readonly State _state;
    private readonly StaticAddressesRecorder _staticAddressesRecorder;
    private CallbackHandler? _callbackHandler;

    // When true will crash if an interrupt targets code at 0000:0000
    private bool _errorOnUninitializedInterruptHandler;

    // interrupt not generated by the code
    private byte? _externalInterruptVectorNumber;

    private bool? _forceLog = false;
    private FunctionHandler _functionHandlerInUse;

    // Value used to read parts of the instruction.
    // CPU uses this internally and adjusts IP after instruction execution is done.
    private ushort _internalIp;

    private IOPortDispatcher? _ioPortDispatcher;
    private bool _isRunning = true;

    public JumpHandler JumpHandler { get; }

    public Cpu(Machine machine, JumpHandler jumpHandler, bool debugMode) {
        _machine = machine;
        _memory = machine.Memory;
        _state = new State();
        _alu = new Alu(_state);
        _stack = new Stack(_memory, _state);
        JumpHandler = jumpHandler;
        _functionHandler = new FunctionHandler(machine, debugMode);
        _functionHandlerInExternalInterrupt = new FunctionHandler(machine, debugMode);
        _functionHandlerInUse = _functionHandler;
        _staticAddressesRecorder = new StaticAddressesRecorder(_state, debugMode);
        _modRM = new ModRM(machine, this);
    }

    public StaticAddressesRecorder GetStaticAddresRecorder => _staticAddressesRecorder;

    public bool IsRunning => _isRunning;

    public void ExecuteNextInstruction() {
        _internalIp = _state.IP;
        _staticAddressesRecorder.Reset();
        String stateString = "";
        if (IsLoggingEnabled()) {
            stateString = _state.ToString();
            _state.ResetCurrentInstructionPrefix();
            _state.CurrentInstructionName = "";
        }
        byte opcode = ProcessPrefixes();
        if (IsLoggingEnabled()) {
            _logger.Debug("Before execution: {@OpCode} {@StateString} ", ConvertUtils.ToHex8(opcode),
                stateString);
        }
        if (_state.ContinueZeroFlagValue != null && IsStringOpcode(opcode)) {
            // continueZeroFlag is either true or false if a rep prefix has been encountered
            ProcessRep(opcode);
        } else {
            ExecOpcode(opcode);
        }
        if (IsLoggingEnabled()) {
            String instructionName = _state.CurrentInstructionNameWithPrefix;
            _logger.Debug("After execution of {@InstructionName} {@State}", instructionName, _state);
        }
        _state.ClearPrefixes();
        _staticAddressesRecorder.Commit();
        _state.IncCycles();
        HandleExternalInterrupt();
        _state.IP = _internalIp;
    }

    public void ExternalInterrupt(byte vectorNumber) {
        // hack: do not let the timer overwrite keyboard.
        if (_externalInterruptVectorNumber is null or not 9) {
            _externalInterruptVectorNumber = vectorNumber;
        }
    }

    public void FarRet(ushort numberOfBytesToPop) {
        _functionHandlerInUse.Ret(CallType.FAR);
        _internalIp = _stack.Pop();
        ushort cs = _stack.Pop();
        JumpHandler.RegisterReturn(_state.CS, _state.IP, cs, _internalIp);
        _state.CS = cs;
        _state.SP = (ushort)(numberOfBytesToPop + _state.SP);
    }

    public Alu GetAlu() => _alu;

    public FunctionHandler GetFunctionHandler() => _functionHandler;

    public FunctionHandler GetFunctionHandlerInExternalInterrupt() => _functionHandlerInExternalInterrupt;

    public FunctionHandler GetFunctionHandlerInUse() => _functionHandlerInUse;

    public Stack GetStack() => _stack;

    public State GetState() => _state;

    public StaticAddressesRecorder GetStaticAddressesRecorder() => _staticAddressesRecorder;

    public void InterruptRet() {
        _functionHandlerInUse.Ret(CallType.INTERRUPT);
        _internalIp = _stack.Pop();
        _state.CS = _stack.Pop();
        _state.Flags.SetFlagRegister(_stack.Pop());
        _functionHandlerInUse = _functionHandler;
    }

    public void NearRet(int numberOfBytesToPop) {
        _functionHandlerInUse.Ret(CallType.NEAR);
        _internalIp = _stack.Pop();
        JumpHandler.RegisterReturn(_state.CS, _state.IP, _state.CS, _internalIp);
        _state.SP = (ushort)(numberOfBytesToPop + _state.SP);
    }

    public ushort NextUint16() {
        var res = _memory.GetUint16(GetInternalIpPhysicalAddress());
        _internalIp += 2;
        return res;
    }

    public byte NextUint8() {
        var res = _memory.GetUint8(GetInternalIpPhysicalAddress());
        _internalIp++;
        return res;
    }

    public void SetCallbackHandler(CallbackHandler callbackHandler) => _callbackHandler = callbackHandler;

    public void SetErrorOnUninitializedInterruptHandler(bool errorOnUninitializedInterruptHandler) {
        _errorOnUninitializedInterruptHandler = errorOnUninitializedInterruptHandler;
    }

    public void SetFlagOnInterruptStack(int flagMask, bool flagValue) {
        uint flagsAddress = MemoryUtils.ToPhysicalAddress(_state.SS, (ushort)(_state.SP + 4));
        int value = _memory.GetUint16(flagsAddress);
        if (flagValue) {
            value |= flagMask;
        } else {
            value &= ~flagMask;
        }
        _memory.SetUint16(flagsAddress, (ushort)value);
    }

    public void SetForceLog(bool forceLog) => _forceLog = forceLog;

    public void SetIoPortDispatcher(IOPortDispatcher? iOPortDispatcher) => _ioPortDispatcher = iOPortDispatcher;

    public void SetRunning(bool running) => _isRunning = running;

    private static bool IsStringOpUpdatingFlags(int stringOpCode)
        => stringOpCode is 0xA6 // CMPSB
            or 0xA7 // CMPSW
            or 0xAE // SCASB
            or 0xAF;

    private void AddCurrentInstructionPrefix(string log) {
        // Optimization, do not calculate the log if it is not used
        if (IsLoggingEnabled()) {
            _state.AddCurrentInstructionPrefix(log);
        }
    }

    private void Callback(ushort callbackIndex) {
        if (IsLoggingEnabled()) {
            if (IsLoggingEnabled()) { SetCurrentInstructionName($"CALLBACK {callbackIndex}"); }
            _logger.Debug("callback {@CallbackIndex}", ConvertUtils.ToHex16(callbackIndex));
        }
        _callbackHandler?.Run(callbackIndex);
    }

    private void ExecOpcode(byte opcode) {
        int regIndex;
        switch (opcode) {
            case 0x00:
                if (IsLoggingEnabled()) { SetCurrentInstructionName("ADD rmb rb"); }
                _modRM.Read();
                _modRM.SetRm8(_alu.Add8(_modRM.GetRm8(), _modRM.GetR8()));
                break;

            case 0x01:
                if (IsLoggingEnabled()) { SetCurrentInstructionName("ADD rmw rw"); }
                _modRM.Read();
                _modRM.SetRm16(_alu.Add16(_modRM.GetRm16(), _modRM.GetR16()));
                break;

            case 0x02:
                if (IsLoggingEnabled()) { SetCurrentInstructionName("ADD rb rmb"); }
                _modRM.Read();
                _modRM.SetR8(_alu.Add8(_modRM.GetR8(), _modRM.GetRm8()));
                break;

            case 0x03:
                if (IsLoggingEnabled()) { SetCurrentInstructionName("ADD rw rmw"); }
                _modRM.Read();
                _modRM.SetR16(_alu.Add16(_modRM.GetR16(), _modRM.GetRm16()));
                break;

            case 0x04:
                if (IsLoggingEnabled()) { SetCurrentInstructionName("ADD AL ib"); }
                _state.AL = _alu.Add8(_state.AL, NextUint8());
                break;

            case 0x05:
                if (IsLoggingEnabled()) { SetCurrentInstructionName("ADD AX iw"); }
                _state.AX = _alu.Add16(_state.AX, NextUint16());
                break;

            case 0x06:
                if (IsLoggingEnabled()) { SetCurrentInstructionName("PUSH ES"); }
                _stack.Push(_state.ES);
                break;

            case 0x07:
                if (IsLoggingEnabled()) { SetCurrentInstructionName("POP ES"); }
                _state.ES = _stack.Pop();
                break;

            case 0x08:
                if (IsLoggingEnabled()) { SetCurrentInstructionName("OR rmb rb"); }
                _modRM.Read();
                _modRM.SetRm8(_alu.Or8(_modRM.GetRm8(), _modRM.GetR8()));
                break;

            case 0x09:
                if (IsLoggingEnabled()) { SetCurrentInstructionName("OR rmw rw"); }
                _modRM.Read();
                _modRM.SetRm16(_alu.Or16(_modRM.GetRm16(), _modRM.GetR16()));
                break;

            case 0x0A:
                if (IsLoggingEnabled()) { SetCurrentInstructionName("OR rb rmb"); }
                _modRM.Read();
                _modRM.SetR8(_alu.Or8(_modRM.GetR8(), _modRM.GetRm8()));
                break;

            case 0x0B:
                if (IsLoggingEnabled()) { SetCurrentInstructionName("OR rw rmw"); }
                _modRM.Read();
                _modRM.SetR16(_alu.Or16(_modRM.GetR16(), _modRM.GetRm16()));
                break;

            case 0x0C:
                if (IsLoggingEnabled()) { SetCurrentInstructionName("OR AL ib"); }
                _state.AL = _alu.Or8(_state.AL, NextUint8());
                break;

            case 0x0D:
                if (IsLoggingEnabled()) { SetCurrentInstructionName("OR AX iw"); }
                _state.AX = _alu.Or16(_state.AX, NextUint16());
                break;

            case 0x0E:
                if (IsLoggingEnabled()) { SetCurrentInstructionName("PUSH CS"); }
                _stack.Push(_state.CS);
                break;

            case 0x0F:
                HandleInvalidOpcode(opcode);
                break;

            case 0x10:
                if (IsLoggingEnabled()) { SetCurrentInstructionName("ADC rmb rb"); }
                _modRM.Read();
                _modRM.SetRm8(_alu.Adc8(_modRM.GetRm8(), _modRM.GetR8()));
                break;

            case 0x11:
                if (IsLoggingEnabled()) { SetCurrentInstructionName("ADC rmw rw"); }
                _modRM.Read();
                _modRM.SetRm16(_alu.Adc16(_modRM.GetRm16(), _modRM.GetR16()));
                break;

            case 0x12:
                if (IsLoggingEnabled()) { SetCurrentInstructionName("ADC rb rmb"); }
                _modRM.Read();
                _modRM.SetR8(_alu.Adc8(_modRM.GetR8(), _modRM.GetRm8()));
                break;

            case 0x13:
                if (IsLoggingEnabled()) { SetCurrentInstructionName("ADC rw rmw"); }
                _modRM.Read();
                _modRM.SetR16(_alu.Adc16(_modRM.GetR16(), _modRM.GetRm16()));
                break;

            case 0x14:
                if (IsLoggingEnabled()) { SetCurrentInstructionName("ADC AL ib"); }
                _state.AL = _alu.Adc8(_state.AL, NextUint8());
                break;

            case 0x15:
                if (IsLoggingEnabled()) { SetCurrentInstructionName("ADC AX iw"); }
                _state.AX = _alu.Adc16(_state.AX, NextUint16());
                break;

            case 0x16:
                if (IsLoggingEnabled()) { SetCurrentInstructionName("PUSH SS"); }
                _stack.Push(_state.SS);
                break;

            case 0x17:
                if (IsLoggingEnabled()) { SetCurrentInstructionName("POP SS"); }
                _state.SS = _stack.Pop();
                break;

            case 0x18:
                if (IsLoggingEnabled()) { SetCurrentInstructionName("SBB rmb rb"); }
                _modRM.Read();
                _modRM.SetRm8(_alu.Sbb8(_modRM.GetRm8(), _modRM.GetR8()));
                break;

            case 0x19:
                if (IsLoggingEnabled()) { SetCurrentInstructionName("SBB rmw rw"); }
                _modRM.Read();
                _modRM.SetRm16(_alu.Sbb16(_modRM.GetRm16(), _modRM.GetR16()));
                break;

            case 0x1A:
                if (IsLoggingEnabled()) { SetCurrentInstructionName("SBB rb rmb"); }
                _modRM.Read();
                _modRM.SetR8(_alu.Sbb8(_modRM.GetR8(), _modRM.GetRm8()));
                break;

            case 0x1B:
                if (IsLoggingEnabled()) { SetCurrentInstructionName("SBB rw rmw"); }
                _modRM.Read();
                _modRM.SetR16(_alu.Sbb16(_modRM.GetR16(), _modRM.GetRm16()));
                break;

            case 0x1C:
                if (IsLoggingEnabled()) { SetCurrentInstructionName("SBB AL ib"); }
                _state.AL = _alu.Sbb8(_state.AL, NextUint8());
                break;

            case 0x1D:
                if (IsLoggingEnabled()) { SetCurrentInstructionName("SBB AX iw"); }
                _state.AX = _alu.Sbb16(_state.AX, NextUint16());
                break;

            case 0x1E:
                if (IsLoggingEnabled()) { SetCurrentInstructionName("PUSH DS"); }
                _stack.Push(_state.DS);
                break;

            case 0x1F:
                if (IsLoggingEnabled()) { SetCurrentInstructionName("POP DS"); }
                _state.DS = _stack.Pop();
                break;

            case 0x20:
                if (IsLoggingEnabled()) { SetCurrentInstructionName("AND rmb rb"); }
                _modRM.Read();
                _modRM.SetRm8(_alu.And8(_modRM.GetRm8(), _modRM.GetR8()));
                break;

            case 0x21:
                if (IsLoggingEnabled()) { SetCurrentInstructionName("AND rmw rw"); }
                _modRM.Read();
                _modRM.SetRm16(_alu.And16(_modRM.GetRm16(), _modRM.GetR16()));
                break;

            case 0x22:
                if (IsLoggingEnabled()) { SetCurrentInstructionName("AND rb rmb"); }
                _modRM.Read();
                _modRM.SetR8(_alu.And8(_modRM.GetR8(), _modRM.GetRm8()));
                break;

            case 0x23:
                if (IsLoggingEnabled()) { SetCurrentInstructionName("AND rw rmw"); }
                _modRM.Read();
                _modRM.SetR16(_alu.And16(_modRM.GetR16(), _modRM.GetRm16()));
                break;

            case 0x24:
                if (IsLoggingEnabled()) { SetCurrentInstructionName("AND AL ib"); }
                _state.AL = _alu.And8(_state.AL, NextUint8());
                break;

            case 0x25:
                if (IsLoggingEnabled()) { SetCurrentInstructionName("AND AX iw"); }
                _state.AX = _alu.And16(_state.AX, NextUint16());
                break;

            case 0x26:
                HandleInvalidOpcodeBecausePrefix(opcode);
                break;

            case 0x27: {
                if (IsLoggingEnabled()) { SetCurrentInstructionName("DAA"); }
                byte initialAL = _state.AL;
                bool initialCF = _state.CarryFlag;
                bool finalAuxillaryFlag = false;
                if ((_state.AL & 0x0F) > 9 || _state.AuxiliaryFlag) {
                    _state.AL = (byte)(_state.AL + 6);
                    finalAuxillaryFlag = true;
                }
                bool finalCarryFlag;
                if (initialAL > 0x99 || initialCF) {
                    _state.AL = (byte)(_state.AL + 0x60);
                    finalCarryFlag = true;
                } else {
                    finalCarryFlag = false;
                }
                // Undocumented behaviour
                _alu.UpdateFlags8(_state.AL);
                _state.AuxiliaryFlag = finalAuxillaryFlag;
                _state.CarryFlag = finalCarryFlag;
                break;
            }
            case 0x28:
                if (IsLoggingEnabled()) { SetCurrentInstructionName("SUB rmb rb"); }
                _modRM.Read();
                _modRM.SetRm8(_alu.Sub8(_modRM.GetRm8(), _modRM.GetR8()));
                break;

            case 0x29:
                if (IsLoggingEnabled()) { SetCurrentInstructionName("SUB rmw rw"); }
                _modRM.Read();
                _modRM.SetRm16(_alu.Sub16(_modRM.GetRm16(), _modRM.GetR16()));
                break;

            case 0x2A:
                if (IsLoggingEnabled()) { SetCurrentInstructionName("SUB rb rmb"); }
                _modRM.Read();
                _modRM.SetR8(_alu.Sub8(_modRM.GetR8(), _modRM.GetRm8()));
                break;

            case 0x2B:
                if (IsLoggingEnabled()) { SetCurrentInstructionName("SUB rw rmw"); }
                _modRM.Read();
                _modRM.SetR16(_alu.Sub16(_modRM.GetR16(), _modRM.GetRm16()));
                break;

            case 0x2C:
                if (IsLoggingEnabled()) { SetCurrentInstructionName("SUB AL ib"); }
                _state.AL = _alu.Sub8(_state.AL, NextUint8());
                break;

            case 0x2D:
                if (IsLoggingEnabled()) { SetCurrentInstructionName("SUB AX iw"); }
                _state.AX = _alu.Sub16(_state.AX, NextUint16());
                break;

            case 0x2E:
                HandleInvalidOpcodeBecausePrefix(opcode);
                break;

            case 0x2F: {
                if (IsLoggingEnabled()) { SetCurrentInstructionName("DAS"); }
                byte initialAL = _state.AL;
                bool initialCF = _state.CarryFlag;
                bool finalAuxillaryFlag = false;
                bool finalCarryFlag = false;
                _state.CarryFlag = false;
                if ((_state.AL & 0x0F) > 9 || _state.AuxiliaryFlag) {
                    _state.AL = (byte)(_state.AL - 6);
                    finalCarryFlag = _state.CarryFlag || initialCF;
                    finalAuxillaryFlag = true;
                }
                if (initialAL > 0x99 || initialCF) {
                    _state.AL = (byte)(_state.AL - 0x60);
                    finalCarryFlag = true;
                }
                // Undocumented behaviour
                _alu.UpdateFlags8(_state.AL);
                _state.AuxiliaryFlag = finalAuxillaryFlag;
                _state.CarryFlag = finalCarryFlag;
                break;
            }
            case 0x30:
                if (IsLoggingEnabled()) { SetCurrentInstructionName("XOR rmb rb"); }
                _modRM.Read();
                _modRM.SetRm8(_alu.Xor8(_modRM.GetRm8(), _modRM.GetR8()));
                break;

            case 0x31:
                if (IsLoggingEnabled()) { SetCurrentInstructionName("XOR rmw rw"); }
                _modRM.Read();
                _modRM.SetRm16(_alu.Xor16(_modRM.GetRm16(), _modRM.GetR16()));
                break;

            case 0x32:
                if (IsLoggingEnabled()) { SetCurrentInstructionName("XOR rb rmb"); }
                _modRM.Read();
                _modRM.SetR8(_alu.Xor8(_modRM.GetR8(), _modRM.GetRm8()));
                break;

            case 0x33:
                if (IsLoggingEnabled()) { SetCurrentInstructionName("XOR rw rmw"); }
                _modRM.Read();
                _modRM.SetR16(_alu.Xor16(_modRM.GetR16(), _modRM.GetRm16()));
                break;

            case 0x34:
                if (IsLoggingEnabled()) { SetCurrentInstructionName("XOR AL mb"); }
                _state.AL = _alu.Xor8(_state.AL, NextUint8());
                break;

            case 0x35:
                if (IsLoggingEnabled()) { SetCurrentInstructionName("XOR AX mw"); }
                _state.AX = _alu.Xor16(_state.AX, NextUint16());
                break;

            case 0x36:
                HandleInvalidOpcodeBecausePrefix(opcode);
                break;

            case 0x37: {
                if (IsLoggingEnabled()) { SetCurrentInstructionName("AAA"); }
                bool finalAuxillaryFlag = false;
                bool finalCarryFlag = false;
                if ((_state.AL & 0x0F) > 9 || _state.AuxiliaryFlag) {
                    _state.AX = (ushort)(_state.AX + 0x106);
                    finalAuxillaryFlag = true;
                    finalCarryFlag = true;
                }
                _state.AL = (byte)(_state.AL & 0x0F);
                // Undocumented behaviour
                _alu.UpdateFlags8(_state.AL);
                _state.AuxiliaryFlag = finalAuxillaryFlag;
                _state.CarryFlag = finalCarryFlag;
                break;
            }
            case 0x38:
                if (IsLoggingEnabled()) { SetCurrentInstructionName("CMP rmb rb"); }
                _modRM.Read();
                _alu.Sub8(_modRM.GetRm8(), _modRM.GetR8());
                break;

            case 0x39:
                if (IsLoggingEnabled()) { SetCurrentInstructionName("CMP rmw rw"); }
                _modRM.Read();
                _alu.Sub16(_modRM.GetRm16(), _modRM.GetR16());
                break;

            case 0x3A:
                if (IsLoggingEnabled()) { SetCurrentInstructionName("CMP rb rmb"); }
                _modRM.Read();
                _alu.Sub8(_modRM.GetR8(), _modRM.GetRm8());
                break;

            case 0x3B:
                if (IsLoggingEnabled()) { SetCurrentInstructionName("CMP rw rmw"); }
                _modRM.Read();
                _alu.Sub16(_modRM.GetR16(), _modRM.GetRm16());
                break;

            case 0x3C:
                if (IsLoggingEnabled()) { SetCurrentInstructionName("CMP AL ib"); }
                _alu.Sub8(_state.AL, NextUint8());
                break;

            case 0x3D:
                if (IsLoggingEnabled()) { SetCurrentInstructionName("CMP AX iw"); }
                _alu.Sub16(_state.AX, NextUint16());
                break;

            case 0x3E:
                HandleInvalidOpcodeBecausePrefix(opcode);
                break;

            case 0x3F: {
                if (IsLoggingEnabled()) { SetCurrentInstructionName("AAS"); }
                bool finalAuxillaryFlag = false;
                bool finalCarryFlag = false;
                if ((_state.AL & 0x0F) > 9 || _state.AuxiliaryFlag) {
                    _state.AX = (ushort)(_state.AX - 6);
                    _state.AH = (byte)(_state.AH - 1);
                    finalAuxillaryFlag = true;
                    finalCarryFlag = true;
                }
                _state.AL = (byte)(_state.AL & 0x0F);
                // Undocumented behaviour
                _alu.UpdateFlags8(_state.AL);
                _state.AuxiliaryFlag = finalAuxillaryFlag;
                _state.CarryFlag = finalCarryFlag;
                break;
            }
            case 0x40:
            case 0x41:
            case 0x42:
            case 0x43:
            case 0x44:
            case 0x45:
            case 0x46:
            case 0x47:
                regIndex = opcode & RegIndexMask;
                if (IsLoggingEnabled()) { SetCurrentInstructionName($"INC {_state.Registers.GetRegName(regIndex)}"); }
                _state.Registers.SetRegister(regIndex, _alu.Inc16(_state.Registers.GetRegister(regIndex)));
                break;

            case 0x48:
            case 0x49:
            case 0x4A:
            case 0x4B:
            case 0x4C:
            case 0x4D:
            case 0x4E:
            case 0x4F:
                regIndex = opcode & RegIndexMask;
                if (IsLoggingEnabled()) { SetCurrentInstructionName($"DEC {_state.Registers.GetRegName(regIndex)}"); }
                _state.Registers.SetRegister(regIndex, _alu.Dec16(_state.Registers.GetRegister(regIndex)));
                break;

            case 0x50:
            case 0x51:
            case 0x52:
            case 0x53:
            case 0x54:
            case 0x55:
            case 0x56:
            case 0x57:
                regIndex = opcode & RegIndexMask;
                if (IsLoggingEnabled()) { SetCurrentInstructionName($"PUSH {_state.Registers.GetRegName(regIndex)}"); }
                _stack.Push(_state.Registers.GetRegister(regIndex));
                break;

            case 0x58:
            case 0x59:
            case 0x5A:
            case 0x5B:
            case 0x5C:
            case 0x5D:
            case 0x5E:
            case 0x5F:
                regIndex = opcode & RegIndexMask;
                if (IsLoggingEnabled()) { SetCurrentInstructionName($"POP {_state.Registers.GetRegName(regIndex)}"); }
                _state.Registers.SetRegister(regIndex, _stack.Pop());
                break;

            case 0x60:
                // 80186
                if (IsLoggingEnabled()) { SetCurrentInstructionName("PUSHA"); }
                ushort sp = _state.SP;
                _stack.Push(_state.AX);
                _stack.Push(_state.CX);
                _stack.Push(_state.DX);
                _stack.Push(_state.BX);
                _stack.Push(sp);
                _stack.Push(_state.BP);
                _stack.Push(_state.SI);
                _stack.Push(_state.DI);
                break;

            case 0x61:
                // 80186
                if (IsLoggingEnabled()) { SetCurrentInstructionName("POPA"); }
                _state.DI = _stack.Pop();
                _state.SI = _stack.Pop();
                _state.BP = _stack.Pop();
                // not restoring SP
                _stack.Pop();
                _state.BX = _stack.Pop();
                _state.DX = _stack.Pop();
                _state.CX = _stack.Pop();
                _state.AX = _stack.Pop();
                break;

            case 0x62:
            case 0x63:
            case 0x64:
            case 0x65:
            case 0x66:
            case 0x67:
                HandleInvalidOpcode(opcode);
                break;

            case 0x68: {
                // 80186
                ushort value = NextUint16();
                if (IsLoggingEnabled()) { SetCurrentInstructionName($"PUSH {ConvertUtils.ToHex16(value)}"); }
                _stack.Push(value);
                break;
            }
            case 0x69: {
                _modRM.Read();
                short value = (short)NextUint16();
                if (IsLoggingEnabled()) { SetCurrentInstructionName($"IMUL16 rm16 {ConvertUtils.ToHex16((ushort)value)}"); }
                int result = _alu.Imul16(value, (short)_modRM.GetRm16());
                _modRM.SetR16((ushort)result);
                break;
            }
            case 0x6A: {
                // 80186
                // sign extend it to 16 bits
                short signedValue = (sbyte)NextUint8();
                ushort value = (ushort)signedValue;
                if (IsLoggingEnabled()) { SetCurrentInstructionName($"PUSH {ConvertUtils.ToHex16(value)}"); }
                _stack.Push(value);
                break;
            }
            case 0x6B: {
                _modRM.Read();
                byte value = NextUint8();
                if (IsLoggingEnabled()) { SetCurrentInstructionName($"IMUL16 rm16 {ConvertUtils.ToHex8(value)}"); }
                int result = _alu.Imul16(value, (short)_modRM.GetRm16());
                _modRM.SetR16((ushort)result);
                break;
            }
            case 0x6C:
            case 0x6D:
            case 0x6E:
            case 0x6F: // INSB, INSW, OUTSB, OUTSW
                ProcessString(opcode);
                break;

            case 0x70:
            case 0x71:
            case 0x72:
            case 0x73:
            case 0x74:
            case 0x75:
            case 0x76:
            case 0x77:
            case 0x78:
            case 0x79:
            case 0x7A:
            case 0x7B:
            case 0x7C:
            case 0x7D:
            case 0x7E:
            case 0x7F:
                Jcc(opcode);
                break;

            case 0x80: // GRP1 rmb ib, GRP1 rmw iw, GRP1 rmb ib, GRP1 rmw ib
            case 0x81:
            case 0x82:
            case 0x83:
                Grp1(opcode);
                break;

            case 0x84:
                if (IsLoggingEnabled()) { SetCurrentInstructionName("TEST rmb rb"); }
                _modRM.Read();
                _alu.And8(_modRM.GetRm8(), _modRM.GetR8());
                break;

            case 0x85:
                if (IsLoggingEnabled()) { SetCurrentInstructionName("TEST rmw rw"); }
                _modRM.Read();
                _alu.And16(_modRM.GetRm16(), _modRM.GetR16());
                break;

            case 0x86: {
                if (IsLoggingEnabled()) { SetCurrentInstructionName("XCHG8"); }
                _modRM.Read();
                byte value1 = _modRM.GetRm8();
                byte value2 = _modRM.GetR8();
                _modRM.SetR8(value1);
                _modRM.SetRm8(value2);
                break;
            }
            case 0x87: {
                if (IsLoggingEnabled()) { SetCurrentInstructionName("XCHG16"); }
                _modRM.Read();
                ushort value1 = _modRM.GetRm16();
                ushort value2 = _modRM.GetR16();
                _modRM.SetR16(value1);
                _modRM.SetRm16(value2);
                break;
            }
            case 0x88:
                if (IsLoggingEnabled()) { SetCurrentInstructionName("MOV rmb rb"); }
                _modRM.Read();
                _modRM.SetRm8(_modRM.GetR8());
                break;

            case 0x89:
                if (IsLoggingEnabled()) { SetCurrentInstructionName("MOV rmw rw"); }
                _modRM.Read();
                _modRM.SetRm16(_modRM.GetR16());
                break;

            case 0x8A:
                if (IsLoggingEnabled()) { SetCurrentInstructionName("MOV rb, rmb"); }
                _modRM.Read();
                _modRM.SetR8(_modRM.GetRm8());
                break;

            case 0x8B:
                if (IsLoggingEnabled()) { SetCurrentInstructionName("MOV rw rmw"); }
                _modRM.Read();
                _modRM.SetR16(_modRM.GetRm16());
                break;

            case 0x8C:
                if (IsLoggingEnabled()) { SetCurrentInstructionName("MOV rmw sreg"); }
                _modRM.Read();
                _modRM.SetRm16((ushort)_modRM.GetSegmentRegister());
                break;

            case 0x8D: {
                if (IsLoggingEnabled()) { SetCurrentInstructionName("LEA"); }
                _modRM.Read();
                ushort? memoryOffset = _modRM.GetMemoryOffset();
                if (memoryOffset == null) {
                    throw new InvalidVMOperationException(this._machine, "Memory address was not read by Mod R/M but it is needed for LEA");
                }
                _modRM.SetR16(memoryOffset.Value);
                break;
            }
            case 0x8E:
                if (IsLoggingEnabled()) { SetCurrentInstructionName("MOV sreg rmw"); }
                _modRM.Read();
                _modRM.SetSegmentRegister(_modRM.GetRm16());
                break;

            case 0x8F:
                if (IsLoggingEnabled()) { SetCurrentInstructionName("POP rmw"); }
                _modRM.Read();
                _modRM.SetRm16(_stack.Pop());
                break;

            case 0x90:
                if (IsLoggingEnabled()) { SetCurrentInstructionName("NOP"); }
                break;

            case 0x91:
            case 0x92:
            case 0x93:
            case 0x94:
            case 0x95:
            case 0x96:
            case 0x97: {
                regIndex = opcode & RegIndexMask;
                if (IsLoggingEnabled()) { SetCurrentInstructionName($"XCHG AX,{_state.Registers.GetRegName(regIndex)}"); }
                ushort value1 = _state.AX;
                ushort value2 = _state.Registers.GetRegister(regIndex);
                _state.AX = value2;
                _state.Registers.SetRegister(regIndex, value1);
                break;
            }
            case 0x98: {
                // Convert byte to word
                if (IsLoggingEnabled()) { SetCurrentInstructionName("CBW"); }
                sbyte value = (sbyte)_state.AL;
                short shortValue = value;
                _state.AX = (ushort)shortValue;
                break;
            }
            case 0x99:
                // Sign extend AX into DX (word to dword)
                if (IsLoggingEnabled()) { SetCurrentInstructionName("CWD"); }
                if (_state.AX >= 0x8000) {
                    _state.DX = 0xFFFF;
                } else {
                    _state.DX = 0;
                }
                break;

            case 0x9A: // FAR CALL
            {
                ushort ip = NextUint16();
                ushort cs = NextUint16();
                if (IsLoggingEnabled()) { SetCurrentInstructionName("FAR CALL"); }
                FarCall(_state.CS, _internalIp, cs, ip);
                break;
            }
            // Do nothing, this is to wait for the FPU which is not implemented
            case 0x9B:
                if (IsLoggingEnabled()) { SetCurrentInstructionName("WAIT"); }
                break;

            case 0x9C:
                if (IsLoggingEnabled()) { SetCurrentInstructionName("PUSHF"); }
                _stack.Push(_state.Flags.FlagRegister);
                break;

            case 0x9D:
                if (IsLoggingEnabled()) { SetCurrentInstructionName("POPF"); }
                _state.Flags.SetFlagRegister(_stack.Pop());
                break;

            case 0x9E:
                if (IsLoggingEnabled()) { SetCurrentInstructionName("SAHF"); }
                _state.Flags.SetFlagRegister(_state.AH);
                break;

            case 0x9F:
                if (IsLoggingEnabled()) { SetCurrentInstructionName("LAHF"); }
                _state.AH = (byte)_state.Flags.FlagRegister;
                break;

            case 0xA0:
                if (IsLoggingEnabled()) { SetCurrentInstructionName("MOV AL moffs8"); }
                _state.AL = _memory.GetUint8(GetDsNextUint16Address());
                _staticAddressesRecorder.SetCurrentAddressOperation(ValueOperation.READ, OperandSize.Byte8);
                break;

            case 0xA1:
                if (IsLoggingEnabled()) { SetCurrentInstructionName("MOV AX moffs16"); }
                _state.AX = _memory.GetUint16(GetDsNextUint16Address());
                _staticAddressesRecorder.SetCurrentAddressOperation(ValueOperation.READ, OperandSize.Word16);
                break;

            case 0xA2:
                if (IsLoggingEnabled()) { SetCurrentInstructionName("MOV moffs8 AL"); }
                _memory.SetUint8(GetDsNextUint16Address(), _state.AL);
                _staticAddressesRecorder.SetCurrentAddressOperation(ValueOperation.WRITE, OperandSize.Byte8);
                break;

            case 0xA3:
                if (IsLoggingEnabled()) { SetCurrentInstructionName("MOV moffs16 AX"); }
                _memory.SetUint16(GetDsNextUint16Address(), _state.AX);
                _staticAddressesRecorder.SetCurrentAddressOperation(ValueOperation.WRITE, OperandSize.Word16);
                break;

            case 0xA4:
            case 0xA5:
            case 0xA6:
            case 0xA7:
                ProcessString(opcode);
                break;

            case 0xA8:
                if (IsLoggingEnabled()) { SetCurrentInstructionName("TEST AL ib"); }
                _alu.And8(_state.AL, NextUint8());
                break;

            case 0xA9:
                if (IsLoggingEnabled()) { SetCurrentInstructionName("TEST AX iw"); }
                _alu.And16(_state.AX, NextUint16());
                break;

            case 0xAA:
            case 0xAB:
            case 0xAC:
            case 0xAD:
            case 0xAE:
            case 0xAF:
                ProcessString(opcode);
                break;

            case 0xB0:
            case 0xB1:
            case 0xB2:
            case 0xB3:
            case 0xB4:
            case 0xB5:
            case 0xB6:
            case 0xB7:
                regIndex = opcode & RegIndexMask;
                if (IsLoggingEnabled()) { SetCurrentInstructionName($"MOV {_state.Registers.GetReg8Name(regIndex)} ib"); }
                _state.Registers.SetRegisterFromHighLowIndex8(regIndex, NextUint8());
                break;

            case 0xB8:
            case 0xB9:
            case 0xBA:
            case 0xBB:
            case 0xBC:
            case 0xBD:
            case 0xBE:
            case 0xBF:
                regIndex = opcode & RegIndexMask;
                if (IsLoggingEnabled()) { SetCurrentInstructionName($"MOV {_state.Registers.GetRegName(regIndex)} iw"); }
                _state.Registers.SetRegister(regIndex, NextUint16());
                break;

            case 0xC0: {
                _modRM.Read();
                int count = this.NextUint8();
                byte value = _modRM.GetRm8();
                if (IsLoggingEnabled()) { SetCurrentInstructionName($"SHL rmb {count}"); }
                _modRM.SetRm8(_alu.Shl8(value, count));
                break;
            }
            case 0xC1: {
                _modRM.Read();
                int count = this.NextUint8();
                ushort value = _modRM.GetRm16();
                if (IsLoggingEnabled()) { SetCurrentInstructionName($"SHL rmw {count}"); }
                _modRM.SetRm16(_alu.Shl16(value, count));
                break;
            }
            case 0xC2: {
                int numberOfBytesToPop = NextUint8();
                if (IsLoggingEnabled()) { SetCurrentInstructionName($"RET and pop {numberOfBytesToPop} bytes"); }
                NearRet(numberOfBytesToPop);
                break;
            }
            case 0xC3:
                if (IsLoggingEnabled()) { SetCurrentInstructionName("RET"); }
                NearRet(0);
                break;

            case 0xC4:
            case 0xC5: {
                // Copy segmented address that is in memory (32bits) into DS/ES and the
                // specified register
                _modRM.Read();
                uint? memoryAddress = _modRM.GetMemoryAddress();
                if (memoryAddress == null) {
                    throw new InvalidVMOperationException(this._machine, "Memory address was not read by Mod R/M but it is needed for LES / LDS");
                }
                _modRM.SetR16(_memory.GetUint16(memoryAddress.Value));
                ushort value = _memory.GetUint16(memoryAddress.Value + 2);
                GetStaticAddressesRecorder().SetCurrentAddressOperation(ValueOperation.READ, OperandSize.Dword32);
                if (opcode == 0xC4) {
                    // LES
                    if (IsLoggingEnabled()) { SetCurrentInstructionName("LES rw md"); }
                    _state.ES = value;
                } else {
                    // LDS
                    if (IsLoggingEnabled()) { SetCurrentInstructionName("LDS rw md"); }
                    _state.DS = value;
                }
                break;
            }
            case 0xC6:
                if (IsLoggingEnabled()) { SetCurrentInstructionName("MOV rmb ib"); }
                _modRM.Read();
                _modRM.SetRm8(NextUint8());
                break;

            case 0xC7:
                if (IsLoggingEnabled()) { SetCurrentInstructionName("MOV rmw iw"); }
                _modRM.Read();
                _modRM.SetRm16(NextUint16());
                break;

            case 0xC8:
            case 0xC9:
                HandleInvalidOpcode(opcode);
                break;

            case 0xCA: {
                byte numberOfBytesToPop = NextUint8();
                if (IsLoggingEnabled()) { SetCurrentInstructionName($"RETF and pop {numberOfBytesToPop} bytes"); }
                FarRet(numberOfBytesToPop);
                break;
            }
            case 0xCB:
                if (IsLoggingEnabled()) { SetCurrentInstructionName("RETF"); }
                FarRet(0);
                break;

            case 0xCC:
                if (IsLoggingEnabled()) { SetCurrentInstructionName("INT 3"); }
                Interrupt(3, false);
                break;

            case 0xCD:
                if (IsLoggingEnabled()) { SetCurrentInstructionName("INT ib"); }
                Interrupt(NextUint8(), false);
                break;

            case 0xCE:
                if (IsLoggingEnabled()) { SetCurrentInstructionName("INTO"); }
                if (_state.OverflowFlag) {
                    Interrupt(4, false);
                }
                break;

            case 0xCF:
                if (IsLoggingEnabled()) { SetCurrentInstructionName("IRET"); }
                InterruptRet();
                break;

            case 0xD0:
            case 0xD1:
            case 0xD2:
            case 0xD3: // GRP2 rmb 1, GRP2 rmw 1, GRP2 rmb CL, GRP2 rmw CL
                Grp2(opcode);
                break;

            case 0xD4: {
                if (IsLoggingEnabled()) { SetCurrentInstructionName("AAM ib"); }
                Aam(NextUint8());
                break;
            }
            case 0xD5: {
                if (IsLoggingEnabled()) { SetCurrentInstructionName("AAD ib"); }
                byte result = (byte)(_state.AL + (_state.AH * NextUint8()));
                _state.AL = result;
                _state.AH = 0;
                _state.Flags.SetFlagRegister(0);
                _alu.UpdateFlags8(result);
                break;
            }
            case 0xD6:
                HandleInvalidOpcode(opcode);
                break;

            case 0xD7: {
                if (IsLoggingEnabled()) { SetCurrentInstructionName("XLAT"); }
                uint address = _modRM.GetAddress(SegmentRegisters.DsIndex, _state.BX) + _state.AL;
                _state.AL = _memory.GetUint8(address);
                break;
            }
            case 0xD8:
                HandleInvalidOpcode(opcode);
                break;

            case 0xD9: {
                _modRM.Read();
                int groupIndex = _modRM.GetRegisterIndex();
                switch (groupIndex) {
                    case 0x7: {
                        // Set the control word to the value expected after init since FPU is not supported.
                        _modRM.SetRm16(0x37F);
                        if (IsLoggingEnabled()) { SetCurrentInstructionName("FNSTCW"); }
                        break;
                    }
                    default: throw new InvalidGroupIndexException(_machine, groupIndex);
                }
                break;
            }
            case 0xDA:
                HandleInvalidOpcode(opcode);
                break;

            case 0xDB: {
                byte opCodeNextByte = NextUint8();
                if (opCodeNextByte != 0xE3) {
                    ushort fullOpCode = (ushort)((opcode << 8) | opCodeNextByte);
                    HandleInvalidOpcode(fullOpCode);
                }
                if (IsLoggingEnabled()) { SetCurrentInstructionName("FNINIT"); }
                // Do nothing, no FPU emulation, but this is used to detect FPU
                break;
            }
            case 0xDC:
                HandleInvalidOpcode(opcode);
                break;

            case 0xDD: {
                _modRM.Read();
                int groupIndex = _modRM.GetRegisterIndex();
                switch (groupIndex) {
                    case 0x7:
                        // Set non zero, means no FPU installed when called after FNINIT.
                        _modRM.SetRm16(0xFF);
                        if (IsLoggingEnabled()) { SetCurrentInstructionName("FNSTSW"); }
                        break;

                    default:
                        throw new InvalidGroupIndexException(_machine, groupIndex);
                }
                break;
            }
            case 0xDE:
            case 0xDF:
                HandleInvalidOpcode(opcode);
                break;

            case 0xE0:
            case 0xE1: { // LOOPZ / LOOPNZ
                bool zeroFlag = (opcode & 0x1) == 1;
                sbyte address = (sbyte)NextUint8();
                if (zeroFlag) {
                    if (IsLoggingEnabled()) { SetCurrentInstructionName($"LOOPZ {address}"); }
                } else {
                    if (IsLoggingEnabled()) { SetCurrentInstructionName($"LOOPNZ {address}"); }
                }
                ushort cx = (ushort)(_state.CX - 1);
                _state.CX = cx;
                if (cx != 0 && _state.ZeroFlag == zeroFlag) {
                    ushort targetIp = (ushort)(_internalIp + address);
                    JumpHandler.RegisterJump(_state.CS, _state.IP, _state.CS, targetIp);
                    _internalIp = targetIp;
                }
                break;
            }
            case 0xE2: // LOOP
            {
                if (IsLoggingEnabled()) { SetCurrentInstructionName("LOOP"); }
                sbyte address = (sbyte)NextUint8();
                ushort cx = (ushort)(_state.CX - 1);
                _state.CX = cx;
                if (cx != 0) {
                    ushort targetIp = (ushort)(_internalIp + address);
                    JumpHandler.RegisterJump(_state.CS, _state.IP, _state.CS, targetIp);
                    _internalIp = targetIp;
                }
                break;
            }
            case 0xE3: // JCXZ
                Jcc(opcode);
                break;

            case 0xE4: {
                byte port = NextUint8();
                if (IsLoggingEnabled()) { SetCurrentInstructionName($"IN AL {ConvertUtils.ToHex8(port)}"); }
                _state.AL = In8(port);
                break;
            }
            case 0xE5: {
                ushort port = NextUint16();
                if (IsLoggingEnabled()) { SetCurrentInstructionName($"IN AL {ConvertUtils.ToHex16(port)}"); }
                _state.AX = In16(port);
                break;
            }
            case 0xE6: {
                byte port = NextUint8();
                byte value = _state.AL;
                if (IsLoggingEnabled()) { SetCurrentInstructionName($"OUT {ConvertUtils.ToHex8(port)} AL={ConvertUtils.ToHex8(value)}"); }
                Out8(port, value);
                break;
            }
            case 0xE7: {
                ushort port = NextUint16();
                ushort value = _state.AX;
                if (IsLoggingEnabled()) { SetCurrentInstructionName($"OUT {ConvertUtils.ToHex16(port)} AX={ConvertUtils.ToHex16(value)}"); }
                Out16(port, value);
                break;
            }
            case 0xE8: {
                if (IsLoggingEnabled()) { SetCurrentInstructionName("CALL NEAR"); }
                ushort nextInstruction = (ushort)(_internalIp + 2);
                short offset = (short)NextUint16();
                ushort callAddress = (ushort)(nextInstruction + offset);
                NearCall(nextInstruction, callAddress);
                break;
            }
            case 0xE9: {
                short offset = (short)NextUint16();
                JumpNear((ushort)(_internalIp + offset));
                break;
            }
            case 0xEA: {
                ushort ip = NextUint16();
                ushort cs = NextUint16();
                JumpFar(cs, ip);
                break;
            }
            case 0xEB: {
                sbyte offset = (sbyte)NextUint8();
                JumpNear((ushort)(_internalIp + offset));
                break;
            }
            case 0xEC: {
                ushort port = _state.DX;
                if (IsLoggingEnabled()) { SetCurrentInstructionName("IN AL DX=" + ConvertUtils.ToHex16(port)); }
                _state.AL = In8(port);
                break;
            }
            case 0xED: {
                ushort port = _state.DX;
                if (IsLoggingEnabled()) { SetCurrentInstructionName("IN AX DX=" + ConvertUtils.ToHex16(port)); }
                _state.AX = In16(port);
                break;
            }
            case 0xEE: {
                ushort port = _state.DX;
                byte value = _state.AL;
                if (IsLoggingEnabled()) { SetCurrentInstructionName("OUT DX=" + ConvertUtils.ToHex16(port) + " AL=" + ConvertUtils.ToHex8(value)); }
                Out8(port, value);
                break;
            }
            case 0xEF: {
                ushort port = _state.DX;
                ushort value = _state.AX;
                if (IsLoggingEnabled()) { SetCurrentInstructionName("OUT DX=" + ConvertUtils.ToHex16(port) + " AX=" + ConvertUtils.ToHex16(value)); }
                Out16(port, value);
                break;
            }
            case 0xF0:
            case 0xF1:
                HandleInvalidOpcode(opcode);
                break;

            case 0xF2:
            case 0xF3:
                HandleInvalidOpcodeBecausePrefix(opcode);
                break;

            case 0xF4:
                if (IsLoggingEnabled()) { SetCurrentInstructionName("HLT"); }
                if (_logger.IsEnabled(Serilog.Events.LogEventLevel.Information)) {
                    _logger.Information("HLT instruction encountered, halting!");
                }
                _isRunning = false;
                break;

            case 0xF5:
                if (IsLoggingEnabled()) { SetCurrentInstructionName("CMC"); }
                _state.CarryFlag = !_state.CarryFlag;
                break;

            case 0xF6: // GRP3a rmb
                Grp3a();
                break;

            case 0xF7: // GRP3b rmw
                Grp3b();
                break;

            case 0xF8:
                if (IsLoggingEnabled()) { SetCurrentInstructionName("CLC"); }
                _state.CarryFlag = false;
                break;

            case 0xF9:
                if (IsLoggingEnabled()) { SetCurrentInstructionName("STC"); }
                _state.CarryFlag = true;
                break;

            case 0xFA:
                if (IsLoggingEnabled()) { SetCurrentInstructionName("CLI"); }
                _state.InterruptFlag = false;
                break;

            case 0xFB:
                if (IsLoggingEnabled()) { SetCurrentInstructionName("STI"); }
                _state.InterruptFlag = true;
                break;

            case 0xFC:
                if (IsLoggingEnabled()) { SetCurrentInstructionName("CLD"); }
                _state.DirectionFlag = false;
                break;

            case 0xFD:
                if (IsLoggingEnabled()) { SetCurrentInstructionName("STD"); }
                _state.DirectionFlag = true;
                break;

            case 0xFE: // GRP4 rmb
                Grp4();
                break;

            case 0xFF: // GRP5 rmw
                Grp5();
                break;
        }
    }
    public void Aam(byte v2) {
        byte v1 = _state.AL;
        if (v2 == 0) {
            HandleDivisionError();
            return;
        }
        byte result = (byte)(v1 % v2);
        _state.AH = (byte)(v1 / v2);
        _state.AL = result;
        _alu.UpdateFlags8(result);
    }

    private void FarCall(ushort returnCS, ushort returnIP, ushort targetCS, ushort targetIP) {
        _stack.Push(returnCS);
        _stack.Push(returnIP);
        _state.CS = targetCS;
        _internalIp = targetIP;
        HandleCall(CallType.FAR, returnCS, returnIP, targetCS, targetIP);
    }

    private static string Generate8Or16Value(bool op1Byte, ushort op1, ushort op2) {
        if (op1Byte) {
            return $"8 ({ConvertUtils.ToHex8((byte)op1)},{ConvertUtils.ToHex8((byte)op2)})";
        }
        return $"16 ({ConvertUtils.ToHex16(op1)},{ConvertUtils.ToHex16(op2)})";
    }

    private static string GenerateGrp1Name(int groupIndex, bool op1Byte, ushort op1, ushort op2) {
        string opName = (groupIndex) switch {
            0 => "ADD",
            1 => "OR",
            2 => "ADC",
            3 => "SBB",
            4 => "AND",
            5 => "SUB",
            6 => "XOR",
            7 => "CMP",
            _ => "",
        };
        return opName + Generate8Or16Value(op1Byte, op1, op2);
    }

    private static string GenerateGrp2Name(int groupIndex, bool op1Byte, ushort op1, ushort op2) {
        var opName = (groupIndex) switch {
            0 => "ROL",
            1 => "ROR",
            2 => "RCL",
            3 => "RCR",
            4 => "SHL",
            5 => "SHR",
            7 => "SAR",
            _ => ""
        };
        return opName + Generate8Or16Value(op1Byte, op1, op2);
    }

    private uint GetDsNextUint16Address() {
        return _modRM.GetAddress(SegmentRegisters.DsIndex, NextUint16(), true);
    }

    private uint GetInternalIpPhysicalAddress() => MemoryUtils.ToPhysicalAddress(_state.CS, _internalIp);

    private uint GetMemoryAddressEsDi() => MemoryUtils.ToPhysicalAddress(_state.ES, _state.DI);

    private uint GetMemoryAddressOverridableDsSi() => _modRM.GetAddress(SegmentRegisters.DsIndex, _state.SI);

    private ushort GetRm8Or16(bool op1Byte) {
        if (op1Byte) {
            return _modRM.GetRm8();
        }
        return _modRM.GetRm16();
    }

    private void Grp1(int opcode) {
        _modRM.Read();
        int groupIndex = _modRM.GetRegisterIndex();
        bool op1Byte = (opcode & 0b01) == 0;
        bool op2Byte = (opcode & 0b11) != 1;
        ushort op2;
        if (op2Byte) {
            if (op1Byte) {
                op2 = NextUint8();
            } else {
                // preserve sign in byte so that it can be extended later if needed
                op2 = (ushort)(sbyte)NextUint8();
            }
        } else {
            op2 = NextUint16();
        }
        ushort op1 = GetRm8Or16(op1Byte);
        if (IsLoggingEnabled()) { SetCurrentInstructionName(GenerateGrp1Name(groupIndex, op1Byte, op1, op2)); }
        ushort res;
        if (op1Byte) {
            res = (groupIndex) switch {
                0 => _alu.Add8((byte)op1, (byte)op2),
                1 => _alu.Or8((byte)op1, (byte)op2),
                2 => _alu.Adc8((byte)op1, (byte)op2),
                3 => _alu.Sbb8((byte)op1, (byte)op2),
                4 => _alu.And8((byte)op1, (byte)op2),
                5 => _alu.Sub8((byte)op1, (byte)op2),
                6 => _alu.Xor8((byte)op1, (byte)op2),
                7 => _alu.Sub8((byte)op1, (byte)op2),
                _ => throw new InvalidGroupIndexException(_machine, groupIndex)
            };
        } else {
            res = (groupIndex) switch {
                0 => _alu.Add16(op1, op2),
                1 => _alu.Or16(op1, op2),
                2 => _alu.Adc16(op1, op2),
                3 => _alu.Sbb16(op1, op2),
                4 => _alu.And16(op1, op2),
                5 => _alu.Sub16(op1, op2),
                6 => _alu.Xor16(op1, op2),
                7 => _alu.Sub16(op1, op2),
                _ => throw new InvalidGroupIndexException(_machine, groupIndex)
            };
        }
        // 7 is CMP so no memory to set
        if (groupIndex != 7) {
            if (op1Byte) {
                _modRM.SetRm8((byte)res);
            } else {
                _modRM.SetRm16(res);
            }
        }
    }

    private void Grp2(int opcode) {
        // GRP2 rmb 1
        _modRM.Read();
        int groupIndex = _modRM.GetRegisterIndex();
        bool op1Byte = (opcode & 0b01) == 0;

        bool valueIsCL = (opcode & 0b10) == 0b10; // if it 0b10, it is CL
        ushort op2;
        if (valueIsCL) {
            op2 = _state.CL;
        } else {
            op2 = 1;
        }
        ushort op1 = GetRm8Or16(op1Byte);
        if (IsLoggingEnabled()) { SetCurrentInstructionName(GenerateGrp2Name(groupIndex, op1Byte, op1, op2)); }
        ushort res;
        if (op1Byte) {
            res = (groupIndex) switch {
                0 => _alu.Rol8((byte)op1, (byte)op2),
                1 => _alu.Ror8((byte)op1, (byte)op2),
                2 => _alu.Rcl8((byte)op1, (byte)op2),
                3 => _alu.Rcr8((byte)op1, (byte)op2),
                4 => _alu.Shl8((byte)op1, (byte)op2),
                5 => _alu.Shr8((byte)op1, (byte)op2),
                7 => _alu.Sar8((byte)op1, (byte)op2),
                _ => throw new InvalidGroupIndexException(_machine, groupIndex)
            };
        } else {
            res = (groupIndex) switch {
                0 => _alu.Rol16(op1, op2),
                1 => _alu.Ror16(op1, op2),
                2 => _alu.Rcl16(op1, op2),
                3 => _alu.Rcr16(op1, op2),
                4 => _alu.Shl16(op1, op2),
                5 => _alu.Shr16(op1, op2),
                7 => _alu.Sar16(op1, op2),
                _ => throw new InvalidGroupIndexException(_machine, groupIndex)
            };
        }
        if (op1Byte) {
            _modRM.SetRm8((byte)res);
        } else {
            _modRM.SetRm16(res);
        }
    }

    private void Grp3a() {
        _modRM.Read();
        int groupIndex = _modRM.GetRegisterIndex();
        switch (groupIndex) {
            case 0: {
                if (IsLoggingEnabled()) { SetCurrentInstructionName("TEST8"); }
                _alu.And8(_modRM.GetRm8(), NextUint8());
                break;
            }
            case 2: {
                if (IsLoggingEnabled()) { SetCurrentInstructionName("NOT8"); }
                _modRM.SetRm8((byte)~_modRM.GetRm8());
                break;
            }
            case 3: {
                if (IsLoggingEnabled()) { SetCurrentInstructionName("NEG8"); }
                byte value = _modRM.GetRm8();
                value = _alu.Sub8(0, value);
                _modRM.SetRm8(value);
                _state.CarryFlag = value != 0;
                break;
            }
            case 4: {
                if (IsLoggingEnabled()) { SetCurrentInstructionName("MUL8"); }
                Mul8(_modRM.GetRm8());
                break;
            }
            case 5: {
                if (IsLoggingEnabled()) { SetCurrentInstructionName("IMUL8"); }
                IMul8(_modRM.GetRm8());
                break;
            }
            case 6: {
                if (IsLoggingEnabled()) { SetCurrentInstructionName("DIV8"); }
                Div8(_modRM.GetRm8());
                break;
            }
            case 7: {
                if (IsLoggingEnabled()) { SetCurrentInstructionName("IDIV8"); }
                IDiv8(_modRM.GetRm8());
                break;
            }
            default:
                throw new InvalidGroupIndexException(_machine, groupIndex);
        }
    }

    private void Grp3b() {
        _modRM.Read();
        int groupIndex = _modRM.GetRegisterIndex();
        switch (groupIndex) {
            case 0:
                if (IsLoggingEnabled()) { SetCurrentInstructionName("TEST16"); }
                _alu.And16(_modRM.GetRm16(), NextUint16());
                break;

            case 2:
                if (IsLoggingEnabled()) { SetCurrentInstructionName("NOT16"); }
                _modRM.SetRm16((ushort)~_modRM.GetRm16());
                break;

            case 3: {
                if (IsLoggingEnabled()) { SetCurrentInstructionName("NEG16"); }
                ushort value = _modRM.GetRm16();
                value = _alu.Sub16(0, value);
                _modRM.SetRm16(value);
                _state.CarryFlag = value != 0;
                break;
            }
            case 4: {
                if (IsLoggingEnabled()) { SetCurrentInstructionName("MUL16"); }
                Mul16(_modRM.GetRm16());
                break;
            }
            case 5: {
                if (IsLoggingEnabled()) { SetCurrentInstructionName("IMUL16"); }
                IMul16(_modRM.GetRm16());
                break;
            }
            case 6: {
                if (IsLoggingEnabled()) { SetCurrentInstructionName("DIV16"); }
                Div16(_modRM.GetRm16());
                break;
            }
            case 7: {
                if (IsLoggingEnabled()) { SetCurrentInstructionName("IDIV16"); }
                IDiv16(_modRM.GetRm16());
                break;
            }
            default:
                throw new InvalidGroupIndexException(_machine, groupIndex);
        }
    }

    private void Grp4() {
        _modRM.Read();
        int groupIndex = _modRM.GetRegisterIndex();
        switch (groupIndex) {
            case 0:
                if (IsLoggingEnabled()) { SetCurrentInstructionName("INC"); }
                _modRM.SetRm8(_alu.Inc8(_modRM.GetRm8()));
                break;

            case 1:
                if (IsLoggingEnabled()) { SetCurrentInstructionName("DEC"); }
                _modRM.SetRm8(_alu.Dec8(_modRM.GetRm8()));
                break;

            case 7:
                // Callback, emulator specific instruction FE38 like in dosbox,
                // to allow interrupts to be overridden by the program
                Callback(NextUint8());
                break;

            default:
                throw new InvalidGroupIndexException(_machine, groupIndex);
        }
    }

    private void Grp5() {
        _modRM.Read();
        int groupIndex = _modRM.GetRegisterIndex();
        switch (groupIndex) {
            case 0:
                if (IsLoggingEnabled()) { SetCurrentInstructionName("INC"); }
                _modRM.SetRm16(_alu.Inc16(_modRM.GetRm16()));
                break;

            case 1:
                if (IsLoggingEnabled()) { SetCurrentInstructionName("DEC"); }
                _modRM.SetRm16(_alu.Dec16(_modRM.GetRm16()));
                break;

            case 2:
                if (IsLoggingEnabled()) { SetCurrentInstructionName("NEAR CALL"); }
                ushort callAddress = _modRM.GetRm16();
                NearCall(_internalIp, callAddress);
                break;

            case 3: {
                if (IsLoggingEnabled()) { SetCurrentInstructionName("FAR CALL"); }
                uint? ipAddress = _modRM.GetMemoryAddress();
                if (ipAddress is null) {
                    return;
                }
                GetStaticAddressesRecorder().SetCurrentAddressOperation(ValueOperation.READ, OperandSize.Dword32Ptr);
                ushort ip = _memory.GetUint16(ipAddress.Value);
                ushort cs = _memory.GetUint16(ipAddress.Value + 2);
                FarCall(_state.CS, _internalIp, cs, ip);
                break;
            }
            case 4: {
                ushort ip = _modRM.GetRm16();
                JumpNear(ip);
                break;
            }
            case 5: {
                uint? ipAddress = _modRM.GetMemoryAddress();
                if (ipAddress is null) {
                    return;
                }
                GetStaticAddressesRecorder().SetCurrentAddressOperation(ValueOperation.READ, OperandSize.Dword32Ptr);
                ushort ip = _memory.GetUint16(ipAddress.Value);
                ushort cs = _memory.GetUint16(ipAddress.Value + 2);
                JumpFar(cs, ip);
                break;
            }
            case 6:
                if (IsLoggingEnabled()) { SetCurrentInstructionName("PUSH"); }
                _stack.Push(_modRM.GetRm16());
                break;

            default:
                throw new InvalidGroupIndexException(_machine, groupIndex);
        }
    }

    
    public void Mul8(byte value) {
        ushort result = _alu.Mul8(_state.AL, value);
        // Upper part of the result goes in AH
        _state.AH = (byte)(result >> 8);
        _state.AL = (byte)result;
    }

    public void IMul8(byte value) {
        sbyte v2 = (sbyte)value;
        short result = _alu.Imul8((sbyte)_state.AL, v2);
        // Upper part of the result goes in AH
        _state.AH = (byte)(result >> 8);
        _state.AL = (byte)result;
    }

    public void Div8(byte v2) {
        ushort v1 = _state.AX;
        byte? result = Alu.Div8(v1, v2);
        if (result == null) {
            HandleDivisionError();
            return;
        }
        _state.AL = result.Value;
        _state.AH = (byte)(v1 % v2);
    }

    public void IDiv8(byte value) {
        short v1 = (short)_state.AX;
        sbyte v2 = (sbyte)value;
        sbyte? result = Alu.Idiv8(v1, v2);
        if (result == null) {
            HandleDivisionError();
            return;
        }
        _state.AL = (byte)result.Value;
        _state.AH = (byte)(v1 % v2);
    }


    public void IDiv16(ushort value) {
        // no sign extension for v1 as it is already a 32bit value
        int v1 = (_state.DX << 16) | _state.AX;
        short v2 = (short)value;
        short? result = Alu.Idiv16(v1, v2);
        if (result == null) {
            HandleDivisionError();
            return;
        }
        _state.AX = (ushort)result.Value;
        _state.DX = (ushort)(v1 % v2);
    }

    public void Div16(ushort v2) {
        uint v1 = (uint)((_state.DX << 16) | _state.AX);
        ushort? result = Alu.Div16(v1, v2);
        if (result == null) {
            HandleDivisionError();
            return;
        }
        _state.AX = result.Value;
        _state.DX = (ushort)(v1 % v2);
    }

    public void Mul16(ushort value) {
        uint result = _alu.Mul16(_state.AX, value);
        // Upper part of the result goes in DX
        _state.DX = (ushort)(result >> 16);
        _state.AX = (ushort)result;
    }

    public void IMul16(ushort value) {
        int result = _alu.Imul16((short)_state.AX, (short)value);
        // Upper part of the result goes in DX
        _state.DX = (ushort)(result >> 16);
        _state.AX = (ushort)result;
    }

    private void HandleCall(CallType callType, ushort returnCS, ushort returnIP, ushort targetCS, ushort targetIP) {
        if (IsLoggingEnabled()) {
            _logger.Debug("CALL {@TargetCsTargetIp}, will return to {@ReturnCsReturnIp}", ConvertUtils.ToSegmentedAddressRepresentation(targetCS, targetIP),
                ConvertUtils.ToSegmentedAddressRepresentation(returnCS, returnIP));
        }
        JumpHandler.RegisterCall(_state.CS, _state.IP, targetCS, targetIP);
        _functionHandlerInUse.Call(callType, targetCS, targetIP, returnCS, returnIP);
    }

    private void HandleDivisionError() {
        // Reset IP because instruction is not finished (this is how an actual CPU behaves)
        _internalIp = _state.IP;
        Interrupt(0, false);
    }

    private void HandleExternalInterrupt() {
        if (_externalInterruptVectorNumber == null || !_state.InterruptFlag) {
            return;
        }
        if (IsLoggingEnabled()) {
            _logger.Debug("Interrupted!, {@ExternalInterruptVectorNumber}", _externalInterruptVectorNumber);
        }
        Interrupt(_externalInterruptVectorNumber, true);
        _externalInterruptVectorNumber = null;
    }

    private void HandleInvalidOpcode(ushort opcode) => throw new InvalidOpCodeException(_machine, opcode, false);

    private void HandleInvalidOpcodeBecausePrefix(byte opcode) => throw new InvalidOpCodeException(_machine, opcode, true);

    private void HandleJump(ushort cs, ushort ip) {
        JumpHandler.RegisterJump(_state.CS, _state.IP, cs, ip);
        _internalIp = ip;
        _state.CS = cs;
    }

    private byte In8(int port) {
        if (_ioPortDispatcher != null) {
            return _ioPortDispatcher.Inb((ushort)port);
        }
        return 0;
    }

    private void Interrupt(byte? vectorNumber, bool external) {
        if (vectorNumber == null) {
            return;
        }
        ushort targetIP = _memory.GetUint16((ushort)(4 * vectorNumber.Value));
        ushort targetCS = _memory.GetUint16((ushort)(4 * vectorNumber.Value + 2));
        if (_errorOnUninitializedInterruptHandler && targetCS == 0 && targetIP == 0) {
            throw new UnhandledOperationException(_machine,
                $"Int was called but vector was not initialized for vectorNumber={ConvertUtils.ToHex(vectorNumber.Value)}");
        }
        ushort returnCS = _state.CS;
        ushort returnIP = _internalIp;
        if (IsLoggingEnabled()) {
            _logger.Debug("int {@VectorNumber} handler found in memory, {@SegmentedAddressRepresentation}", ConvertUtils.ToHex(vectorNumber.Value),
                ConvertUtils.ToSegmentedAddressRepresentation(targetCS, targetIP));
        }
        _stack.Push(_state.Flags.FlagRegister);
        _stack.Push(returnCS);
        _stack.Push(returnIP);
        _state.InterruptFlag = false;
        _internalIp = targetIP;
        _state.CS = targetCS;
        bool recordReturn = true;
        if (external) {
            _functionHandlerInUse = _functionHandlerInExternalInterrupt;
            recordReturn = false;
        }
        _functionHandlerInUse.Icall(CallType.INTERRUPT, targetCS, targetIP, returnCS, returnIP, vectorNumber.Value,
            recordReturn);
    }

    private ushort In16(int port) {
        if (_ioPortDispatcher != null) {
            return _ioPortDispatcher.Inw((ushort)port);
        }
        return 0;
    }

    private bool IsLoggingEnabled() {
        if (_forceLog is null) {
            return _logger.IsEnabled(Serilog.Events.LogEventLevel.Debug);
        }
        return _forceLog.Value;
    }

    private static bool IsStringOpcode(int opcode) {
        return _stringOpCodes.Contains(opcode);
    }

    /// <summary>
    /// Jumps handling
    /// </summary>
    private void Jcc(ushort opcode) {
        sbyte address = (sbyte)NextUint8();
        bool jump = opcode switch {
            0x70 => _state.OverflowFlag,
            0x71 => !_state.OverflowFlag,
            0x72 => _state.CarryFlag,
            0x73 => !_state.CarryFlag,
            0x74 => _state.ZeroFlag,
            0x75 => !_state.ZeroFlag,
            0x76 => _state.CarryFlag || _state.ZeroFlag,
            0x77 => !_state.CarryFlag && !_state.ZeroFlag,
            0x78 => _state.SignFlag,
            0x79 => !_state.SignFlag,
            0x7A => _state.ParityFlag,
            0x7B => !_state.ParityFlag,
            0x7C => _state.SignFlag != _state.OverflowFlag,
            0x7D => _state.SignFlag == _state.OverflowFlag,
            0x7E => _state.ZeroFlag || _state.SignFlag != _state.OverflowFlag,
            0x7F => !_state.ZeroFlag && _state.SignFlag == _state.OverflowFlag,
            0xE3 => _state.CX == 0,
            _ => throw new InvalidOpCodeException(_machine, opcode, false)
        };
        if (IsLoggingEnabled()) {
            SetCurrentInstructionName(opcode switch {
                0x70 => "JO",
                0x71 => "JNO",
                0x72 => "JB",
                0x73 => "JNB",
                0x74 => "JZ",
                0x75 => "JNZ",
                0x76 => "JBE",
                0x77 => "JA",
                0x78 => "JS",
                0x79 => "JNS",
                0x7A => "JP",
                0x7B => "JPO",
                0x7C => "JL",
                0x7D => "JGE",
                0x7E => "JNG",
                0x7F => "JG",
                0xE3 => "JCXZ",
                _ => ""
            } + $" {address} {nameof(jump)}? {jump}");
        }
        if (jump) {
            HandleJump(_state.CS, (ushort)(_internalIp + address));
        }
    }

    private void JumpFar(ushort cs, ushort ip) {
        if (IsLoggingEnabled()) { SetCurrentInstructionName($"JMP FAR {ConvertUtils.ToSegmentedAddressRepresentation(cs, ip)}"); }
        HandleJump(cs, ip);
    }

    private void JumpNear(ushort ip) {
        if (IsLoggingEnabled()) { SetCurrentInstructionName($"JMP NEAR {ConvertUtils.ToSegmentedAddressRepresentation(_state.CS, ip)}"); }
        HandleJump(_state.CS, ip);
    }

    private void NearCall(ushort returnIP, ushort callIP) {
        _stack.Push(returnIP);
        _internalIp = callIP;
        HandleCall(CallType.NEAR, _state.CS, returnIP, _state.CS, callIP);
    }

    public void Out8(int port, byte val) {
        if (_ioPortDispatcher != null) {
            _ioPortDispatcher.Outb((ushort)port, val);
        }
    }

    public void Out16(int port, ushort val) {
        if (_ioPortDispatcher != null) {
            _ioPortDispatcher.Outw((ushort)port, val);
        }
    }

    private bool ProcessPrefix(int opcode) {
        switch (opcode) {
            case 0x26:
                if (IsLoggingEnabled()) {
                    AddCurrentInstructionPrefix("ES:");
                }
                _state.SegmentOverrideIndex = SegmentRegisters.EsIndex;
                break;

            case 0x2E:
                if (IsLoggingEnabled()) {
                    AddCurrentInstructionPrefix("CS:");
                }
                _state.SegmentOverrideIndex = SegmentRegisters.CsIndex;
                break;

            case 0x36:
                if (IsLoggingEnabled()) {
                    AddCurrentInstructionPrefix("SS:");
                }
                _state.SegmentOverrideIndex = SegmentRegisters.SsIndex;
                break;

            case 0x3E:
                if (IsLoggingEnabled()) {
                    AddCurrentInstructionPrefix("DS:");
                }
                _state.SegmentOverrideIndex = SegmentRegisters.DsIndex;
                break;

            case 0x64:
                if (IsLoggingEnabled()) {
                    AddCurrentInstructionPrefix("FS:");
                }
                _state.SegmentOverrideIndex = SegmentRegisters.FsIndex;
                break;

            case 0x65:
                if (IsLoggingEnabled()) {
                    AddCurrentInstructionPrefix("GS:");
                }
                _state.SegmentOverrideIndex = SegmentRegisters.GsIndex;
                break;

            case 0xF0:
                if (IsLoggingEnabled()) {
                    AddCurrentInstructionPrefix("LOCK");
                }
                break;

            case 0xF2:
            case 0xF3: // REPNZ, REPZ
            {
                bool continueZeroFlagValue = (opcode & 1) == 1;
                _state.ContinueZeroFlagValue = continueZeroFlagValue;
                if (IsLoggingEnabled()) {
                    AddCurrentInstructionPrefix($"REP{(continueZeroFlagValue ? "Z" : "")}");
                }
                break;
            }
            default:
                return false;
        }
        return true;
    }

    private byte ProcessPrefixes() {
        byte opcode = NextUint8();
        while (ProcessPrefix(opcode)) {
            opcode = NextUint8();
        }
        return opcode;
    }

    private void ProcessRep(byte opcode) {
        // repeat while zero flag is false for REPNZ (last bit is 0)
        // or while zero flag is true for REPZ (last bit is 1)
        bool? continueZeroFlagValue = _state.ContinueZeroFlagValue;
        // For some instructions, zero flag is not to be checked
        bool checkZeroFlag = IsStringOpUpdatingFlags(opcode);
        ushort cx = _state.CX;
        while (cx != 0) {
            // re-set the segment override that may have been cleared. No need to reset ip
            // as string instructions don't modify it and are only one byte.
            ProcessString(opcode);
            cx--;

            if (_logger.IsEnabled(Serilog.Events.LogEventLevel.Verbose)) {
                _logger.Verbose("{@Rep} Loop, {@Cx}, {@If}, {@CheckZeroFlag}, {@ContinueZF}",
                    _state.CurrentInstructionNameWithPrefix,
                    ConvertUtils.ToHex(cx), _state.ZeroFlag, checkZeroFlag, continueZeroFlagValue);
            }
            // Not all the string operations require checking the zero flag...
            if (checkZeroFlag && _state.ZeroFlag != continueZeroFlagValue) {
                break;
            }
        }
        _state.CX = cx;
    }

    private void ProcessString(ushort opcode) {
        int diff = (_state.DirectionFlag ? -1 : 1) << (opcode & 1);
        switch (opcode) {
            case 0xA4: {
                if (IsLoggingEnabled()) { SetCurrentInstructionName("MOVSB"); }
                byte value = _memory.GetUint8(GetMemoryAddressOverridableDsSi());
                _memory.SetUint8(GetMemoryAddressEsDi(), value);
                _state.SI = (ushort)(_state.SI + diff);
                _state.DI = (ushort)(_state.DI + diff);
                break;
            }
            case 0xA5: {
                if (IsLoggingEnabled()) { SetCurrentInstructionName("MOVSW"); }
                ushort value = _memory.GetUint16(GetMemoryAddressOverridableDsSi());
                _memory.SetUint16(GetMemoryAddressEsDi(), value);
                _state.SI = (ushort)(_state.SI + diff);
                _state.DI = (ushort)(_state.DI + diff);
                break;
            }
            case 0xA6: {
                if (IsLoggingEnabled()) { SetCurrentInstructionName("CMPSB"); }
                byte value = _memory.GetUint8(GetMemoryAddressOverridableDsSi());
                _alu.Sub8(value, _memory.GetUint8(GetMemoryAddressEsDi()));
                _state.SI = (ushort)(_state.SI + diff);
                _state.DI = (ushort)(_state.DI + diff);
                break;
            }
            case 0xA7: {
                if (IsLoggingEnabled()) { SetCurrentInstructionName("CMPSW"); }
                ushort value = _memory.GetUint16(GetMemoryAddressOverridableDsSi());
                _alu.Sub16(value, _memory.GetUint16(GetMemoryAddressEsDi()));
                _state.SI = (ushort)(_state.SI + diff);
                _state.DI = (ushort)(_state.DI + diff);
                break;
            }
            case 0xAA:
                if (IsLoggingEnabled()) { SetCurrentInstructionName("STOSB"); }
                _memory.SetUint8(GetMemoryAddressEsDi(), _state.AL);
                _state.DI = (ushort)(_state.DI + diff);
                break;

            case 0xAB:
                if (IsLoggingEnabled()) { SetCurrentInstructionName("STOSW"); }
                _memory.SetUint16(GetMemoryAddressEsDi(), _state.AX);
                _state.DI = (ushort)(_state.DI + diff);
                break;

            case 0xAC: {
                if (IsLoggingEnabled()) { SetCurrentInstructionName("LODSB"); }
                byte value = _memory.GetUint8(GetMemoryAddressOverridableDsSi());
                _state.AL = value;
                _state.SI = (ushort)(_state.SI + diff);
                break;
            }
            case 0xAD: {
                if (IsLoggingEnabled()) { SetCurrentInstructionName("LODSW"); }
                ushort value = _memory.GetUint16(GetMemoryAddressOverridableDsSi());
                _state.AX = value;
                _state.SI = (ushort)(_state.SI + diff);
                break;
            }
            case 0xAE:
                if (IsLoggingEnabled()) { SetCurrentInstructionName("SCASB"); }
                _alu.Sub8(_state.AL, _memory.GetUint8(GetMemoryAddressEsDi()));
                _state.DI = (ushort)(_state.DI + diff);
                break;

            case 0xAF:
                if (IsLoggingEnabled()) { SetCurrentInstructionName("SCASW"); }
                _alu.Sub16(_state.AX, _memory.GetUint16(GetMemoryAddressEsDi()));
                _state.DI = (ushort)(_state.DI + diff);
                break;

            case 0x6C: {
                if (IsLoggingEnabled()) { SetCurrentInstructionName("INSB"); }
                ushort port = _state.DX;
                byte value = In8(port);
                _memory.SetUint8(GetMemoryAddressEsDi(), value);
                _state.SI = (ushort)(_state.DI + diff);
                break;
            }
            case 0x6D: {
                if (IsLoggingEnabled()) { SetCurrentInstructionName("INSW"); }
                ushort port = _state.DX;
                ushort value = In16(port);
                _memory.SetUint16(GetMemoryAddressEsDi(), value);
                _state.SI = (ushort)(_state.DI + diff);
                break;
            }
            case 0x6E: {
                if (IsLoggingEnabled()) { SetCurrentInstructionName("OUTSB"); }
                ushort port = _state.DX;
                byte value = _memory.GetUint8(GetMemoryAddressOverridableDsSi());
                Out8(port, value);
                _state.SI = (ushort)(_state.SI + diff);
                break;
            }
            case 0x6F: {
                if (IsLoggingEnabled()) { SetCurrentInstructionName("OUTSW"); }
                ushort port = _state.DX;
                ushort value = _memory.GetUint16(GetMemoryAddressOverridableDsSi());
                Out16(port, value);
                _state.SI = (ushort)(_state.SI + diff);
                break;
            }
            default:
                HandleInvalidOpcode(opcode);
                break;
        }
    }

    private void SetCurrentInstructionName(string log) {
        // Optimization, do not calculate the log if it is not used
        if (IsLoggingEnabled()) {
            _state.CurrentInstructionName = log;
        }
    }

    // SCASW
}