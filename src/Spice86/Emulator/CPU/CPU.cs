namespace Spice86.Emulator.Cpu;

using Serilog;

using Spice86.Emulator.Callback;
using Spice86.Emulator.Errors;
using Spice86.Emulator.Function;
using Spice86.Emulator.IOPorts;
using Spice86.Emulator.Machine;
using Spice86.Emulator.Memory;
using Spice86.Utils;

using System;
using System.Collections.Generic;
using System.Linq;

/// <summary>
/// Implementation of a 8086 CPU. <br /> It has some 80186, 80286 and 80386 instructions as some
/// program use them. <br /> It also has some x87 FPU instructions to support telling the programs
/// that x87 is not supported :) <br /> Some docs that helped the implementation: <ul> <li>
/// Instructions decoding: http://rubbermallet.org/8086%20notes.pdf and
/// http://ref.x86asm.net/coder32.html </li><li> Instructions implementation details:
/// https://www.felixcloutier.com/x86/ </li><li> Pure 8086 instructions:
/// https://jbwyatt.com/253/emu/8086_instruction_set.html </li></ul>
/// TODO: Complete it !
/// </summary>
public class Cpu
{
    private static readonly ILogger _logger = Log.Logger.ForContext<Cpu>();

    // Extract regIndex from opcode
    private const int REG_INDEX_MASK = 0b111;

    private static readonly List<int> PREFIXES_OPCODES = new int[] { 0x26, 0x2E, 0x36, 0x3E, 0x64, 0x65, 0xF0, 0xF2, 0xF3 }.ToList();
    private static readonly List<int> STRING_OPCODES = new int[] { 0xA4, 0xA5, 0xA6, 0xA7, 0xAA, 0xAB, 0xAC, 0xAD, 0xAE, 0xAF, 0x6C, 0x6D, 0x6E, 0x6F }.ToList();

    private readonly Machine _machine;
    private readonly State _state;
    private readonly Memory _memory;
    private readonly ModRM _modRM;
    private readonly Alu _alu;
    private readonly Stack _stack;
    private CallbackHandler? _callbackHandler;
    private IOPortDispatcher? _ioPortDispatcher;
    private readonly FunctionHandler _functionHandler;
    private readonly FunctionHandler _functionHandlerInExternalInterrupt;
    private FunctionHandler _functionHandlerInUse;
    private readonly StaticAddressesRecorder _staticAddressesRecorder;

    // Value used to read parts of the instruction.
    // CPU uses this internally and adjusts IP after instruction execution is done.
    private int _internalIp;

    private bool _running = true;

    // interrupt not generated by the code
    private int? _externalInterruptVectorNumber;

    // When true will crash if an interrupt targets code at 0000:0000
    private bool _errorOnUninitializedInterruptHandler;

    private bool? _forceLog;

    public Cpu(Machine machine, bool debugMode)
    {
        _machine = machine;
        _memory = machine.GetMemory();
        _state = new State();
        _alu = new Alu(_state);
        _stack = new Stack(_memory, _state);
        _functionHandler = new FunctionHandler(machine, debugMode);
        _functionHandlerInExternalInterrupt = new FunctionHandler(machine, debugMode);
        _functionHandlerInUse = _functionHandler;
        _staticAddressesRecorder = new StaticAddressesRecorder(_state, debugMode);
        _modRM = new ModRM(machine, this);
    }

    public State GetState() => _state;

    public Alu GetAlu() => _alu;

    public Stack GetStack() => _stack;

    public bool IsRunning => _running;

    public void SetRunning(bool running) => _running = running;

    public void SetCallbackHandler(CallbackHandler callbackHandler) => _callbackHandler = callbackHandler;

    public void SetIoPortDispatcher(IOPortDispatcher iOPortDispatcher) => _ioPortDispatcher = iOPortDispatcher;

    public FunctionHandler GetFunctionHandler() => _functionHandler;

    public FunctionHandler GetFunctionHandlerInExternalInterrupt() => _functionHandlerInExternalInterrupt;

    public FunctionHandler GetFunctionHandlerInUse() => _functionHandlerInUse;

    public StaticAddressesRecorder GetStaticAddresRecorder => _staticAddressesRecorder;

    public void SetForceLog(bool forceLog) => _forceLog = forceLog;

    public void ExternalInterrupt(int vectorNumber)
    {
        // hack: do not let the timer overwrite keyboard.
        if (_externalInterruptVectorNumber == null || _externalInterruptVectorNumber != 9)
        {
            _externalInterruptVectorNumber = vectorNumber;
        }
    }

    public void SetErrorOnUninitializedInterruptHandler(bool errorOnUninitializedInterruptHandler)
    {
        _errorOnUninitializedInterruptHandler = errorOnUninitializedInterruptHandler;
    }

    private void AddCurrentInstructionPrefix(Func<String> getLog)
    {
        // Optimization, do not calculate the log if it is not used
        if (IsLoggingEnabled())
        {
            _state.AddCurrentInstructionPrefix(getLog.Invoke());
        }
    }

    private void SetCurrentInstructionName(Func<String> getLog)
    {
        // Optimization, do not calculate the log if it is not used
        if (IsLoggingEnabled())
        {
            _state.SetCurrentInstructionName(getLog.Invoke());
        }
    }

    private bool IsLoggingEnabled()
    {
        if (_forceLog == null)
        {
            return _logger.IsEnabled(Serilog.Events.LogEventLevel.Debug);
        }
        return _forceLog.Value;
    }

    public void ExecuteNextInstruction()
    {
        _internalIp = _state.GetIP();
        _staticAddressesRecorder.Reset();
        var stateString = "";
        if (IsLoggingEnabled())
        {
            stateString = _state.ToString();
            _state.ResetCurrentInstructionPrefix();
            _state.SetCurrentInstructionName("");
        }
        int opcode = ProcessPrefixes();
        if (IsLoggingEnabled())
        {
            _logger.Debug("Before execution: {@OpCode} {@StateString} ", ConvertUtils.ToHex8(opcode),
                stateString);
        }
        if (_state.GetContinueZeroFlagValue() != null && IsStringOpcode(opcode))
        {
            // continueZeroFlag is either true or false if a rep prefix has been encountered
            ProcessRep(opcode);
        }
        else
        {
            ExecOpcode(opcode);
        }
        if (IsLoggingEnabled())
        {
            String instructionName = _state.GetCurrentInstructionNameWithPrefix();
            _logger.Debug("After execution of {@InstructionName} {@State}", instructionName, _state);
        }
        _state.ClearPrefixes();
        _staticAddressesRecorder.Commit();
        _state.IncCycles();
        HandleExternalInterrupt();
        _state.SetIP(_internalIp);
    }

    private void ExecOpcode(int opcode)
    {
        if (opcode == 0x00)
        {
            SetCurrentInstructionName(() => "ADD rmb rb");
            _modRM.Read();
            _modRM.SetRm8(_alu.Add8(_modRM.GetRm8(), _modRM.GetR8()));
        }
        if (opcode == 0x01)
        {
            SetCurrentInstructionName(() => "ADD rmw rw");
            _modRM.Read();
            _modRM.SetRm16(_alu.Add16(_modRM.GetRm16(), _modRM.GetR16()));
        }
        if (opcode == 0x02)
        {
            SetCurrentInstructionName(() => "ADD rb rmb");
            _modRM.Read();
            _modRM.SetR8(_alu.Add8(_modRM.GetR8(), _modRM.GetRm8()));
        }
        if (opcode == 0x03)
        {
            SetCurrentInstructionName(() => "ADD rw rmw");
            _modRM.Read();
            _modRM.SetR16(_alu.Add16(_modRM.GetR16(), _modRM.GetRm16()));
        }
        if (opcode == 0x04)
        {
            SetCurrentInstructionName(() => "ADD AL ib");
            _state.SetAL(_alu.Add8(_state.GetAL(), NextUint8()));
        }
        if (opcode == 0x05)
        {
            SetCurrentInstructionName(() => "ADD AX iw");
            _state.SetAX(_alu.Add16(_state.GetAX(), NextUint16()));
        }
        if (opcode == 0x06)
        {
            SetCurrentInstructionName(() => "PUSH ES");
            _stack.Push(_state.GetES());
        }
        if (opcode == 0x07)
        {
            SetCurrentInstructionName(() => "POP ES");
            _state.SetES(_stack.Pop());
        }
        if (opcode == 0x08)
        {
            SetCurrentInstructionName(() => "OR rmb rb");
            _modRM.Read();
            _modRM.SetRm8(_alu.Or8(_modRM.GetRm8(), _modRM.GetR8()));
        }
        if (opcode == 0x09)
        {
            SetCurrentInstructionName(() => "OR rmw rw");
            _modRM.Read();
            _modRM.SetRm16(_alu.Or16(_modRM.GetRm16(), _modRM.GetR16()));
        }
        if (opcode == 0x0A)
        {
            SetCurrentInstructionName(() => "OR rb rmb");
            _modRM.Read();
            _modRM.SetR8(_alu.Or8(_modRM.GetR8(), _modRM.GetRm8()));
        }
        if (opcode == 0x0B)
        {
            SetCurrentInstructionName(() => "OR rw rmw");
            _modRM.Read();
            _modRM.SetR16(_alu.Or16(_modRM.GetR16(), _modRM.GetRm16()));
        }
        if (opcode == 0x0C)
        {
            SetCurrentInstructionName(() => "OR AL ib");
            _state.SetAL(_alu.Or8(_state.GetAL(), NextUint8()));
        }
        if (opcode == 0x0D)
        {
            SetCurrentInstructionName(() => "OR AX iw");
            _state.SetAX(_alu.Or16(_state.GetAX(), NextUint16()));
        }
        if (opcode == 0x0E)
        {
            SetCurrentInstructionName(() => "PUSH CS");
            _stack.Push(_state.GetCS());
        }
        if (opcode == 0x0F)
        {
            HandleInvalidOpcode(opcode);
        }
        if (opcode == 0x10)
        {
            SetCurrentInstructionName(() => "ADC rmb rb");
            _modRM.Read();
            _modRM.SetRm8(_alu.Adc8(_modRM.GetRm8(), _modRM.GetR8()));
        }
        if (opcode == 0x11)
        {
            SetCurrentInstructionName(() => "ADC rmw rw");
            _modRM.Read();
            _modRM.SetRm16(_alu.Adc16(_modRM.GetRm16(), _modRM.GetR16()));
        }
        if (opcode == 0x12)
        {
            SetCurrentInstructionName(() => "ADC rb rmb");
            _modRM.Read();
            _modRM.SetR8(_alu.Adc8(_modRM.GetR8(), _modRM.GetRm8()));
        }
        if (opcode == 0x13)
        {
            SetCurrentInstructionName(() => "ADC rw rmw");
            _modRM.Read();
            _modRM.SetR16(_alu.Adc16(_modRM.GetR16(), _modRM.GetRm16()));
        }
        if (opcode == 0x14)
        {
            SetCurrentInstructionName(() => "ADC AL ib");
            _state.SetAL(_alu.Adc8(_state.GetAL(), NextUint8()));
        }
        if (opcode == 0x15)
        {
            SetCurrentInstructionName(() => "ADC AX iw");
            _state.SetAX(_alu.Adc16(_state.GetAX(), NextUint16()));
        }
        if (opcode == 0x16)
        {
            SetCurrentInstructionName(() => "PUSH SS");
            _stack.Push(_state.GetSS());
        }
        if (opcode == 0x17)
        {
            SetCurrentInstructionName(() => "POP SS");
            _state.SetSS(_stack.Pop());
        }
        if (opcode == 0x18)
        {
            SetCurrentInstructionName(() => "SBB rmb rb");
            _modRM.Read();
            _modRM.SetRm8(_alu.Sbb8(_modRM.GetRm8(), _modRM.GetR8()));
        }
        if (opcode == 0x19)
        {
            SetCurrentInstructionName(() => "SBB rmw rw");
            _modRM.Read();
            _modRM.SetRm16(_alu.Sbb16(_modRM.GetRm16(), _modRM.GetR16()));
        }
        if (opcode == 0x1A)
        {
            SetCurrentInstructionName(() => "SBB rb rmb");
            _modRM.Read();
            _modRM.SetR8(_alu.Sbb8(_modRM.GetR8(), _modRM.GetRm8()));
        }
        if (opcode == 0x1B)
        {
            SetCurrentInstructionName(() => "SBB rw rmw");
            _modRM.Read();
            _modRM.SetR16(_alu.Sbb16(_modRM.GetR16(), _modRM.GetRm16()));
        }
        if (opcode == 0x1C)
        {
            SetCurrentInstructionName(() => "SBB AL ib");
            _state.SetAL(_alu.Sbb8(_state.GetAL(), NextUint8()));
        }
        if (opcode == 0x1D)
        {
            SetCurrentInstructionName(() => "SBB AX iw");
            _state.SetAX(_alu.Sbb16(_state.GetAX(), NextUint16()));
        }
        if (opcode == 0x1E)
        {
            SetCurrentInstructionName(() => "PUSH DS");
            _stack.Push(_state.GetDS());
        }
        if (opcode == 0x1F)
        {
            SetCurrentInstructionName(() => "POP DS");
            _state.SetDS(_stack.Pop());
        }
        if (opcode == 0x20)
        {
            SetCurrentInstructionName(() => "AND rmb rb");
            _modRM.Read();
            _modRM.SetRm8(_alu.And8(_modRM.GetRm8(), _modRM.GetR8()));
        }
        if (opcode == 0x21)
        {
            SetCurrentInstructionName(() => "AND rmw rw");
            _modRM.Read();
            _modRM.SetRm16(_alu.And16(_modRM.GetRm16(), _modRM.GetR16()));
        }
        if (opcode == 0x22)
        {
            SetCurrentInstructionName(() => "AND rb rmb");
            _modRM.Read();
            _modRM.SetR8(_alu.And8(_modRM.GetR8(), _modRM.GetRm8()));
        }
        if (opcode == 0x23)
        {
            SetCurrentInstructionName(() => "AND rw rmw");
            _modRM.Read();
            _modRM.SetR16(_alu.And16(_modRM.GetR16(), _modRM.GetRm16()));
        }
        if (opcode == 0x24)
        {
            SetCurrentInstructionName(() => "AND AL ib");
            _state.SetAL(_alu.And8(_state.GetAL(), NextUint8()));
        }
        if (opcode == 0x25)
        {
            SetCurrentInstructionName(() => "AND AX iw");
            _state.SetAX(_alu.And16(_state.GetAX(), NextUint16()));
        }
        if (opcode == 0x26)
        {
            HandleInvalidOpcodeBecausePrefix(opcode);
        }
        if (opcode == 0x27)
        {
            SetCurrentInstructionName(() => "DAA");
            int initialAL = _state.GetAL();
            bool initialCF = _state.GetCarryFlag();
            bool finalAuxillaryFlag = false;
            bool finalCarryFlag = false;
            if ((_state.GetAL() & 0x0F) > 9 || _state.GetAuxiliaryFlag())
            {
                _state.SetAL(_state.GetAL() + 6);
                finalAuxillaryFlag = true;
            }

            if (initialAL > 0x99 || initialCF)
            {
                _state.SetAL(_state.GetAL() + 0x60);
                finalCarryFlag = true;
            }
            else
            {
                finalCarryFlag = false;
            }
            // Undocumented behaviour
            _alu.UpdateFlags8(_state.GetAL());
            _state.SetAuxiliaryFlag(finalAuxillaryFlag);
            _state.SetCarryFlag(finalCarryFlag);
        }
        if (opcode == 0x28)
        {
            SetCurrentInstructionName(() => "SUB rmb rb");
            _modRM.Read();
            _modRM.SetRm8(_alu.Sub8(_modRM.GetRm8(), _modRM.GetR8()));
        }
        if (opcode == 0x29)
        {
            SetCurrentInstructionName(() => "SUB rmw rw");
            _modRM.Read();
            _modRM.SetRm16(_alu.Sub16(_modRM.GetRm16(), _modRM.GetR16()));
        }
        if (opcode == 0x2A)
        {
            SetCurrentInstructionName(() => "SUB rb rmb");
            _modRM.Read();
            _modRM.SetR8(_alu.Sub8(_modRM.GetR8(), _modRM.GetRm8()));
        }
        if (opcode == 0x2B)
        {
            SetCurrentInstructionName(() => "SUB rw rmw");
            _modRM.Read();
            _modRM.SetR16(_alu.Sub16(_modRM.GetR16(), _modRM.GetRm16()));
        }
        if (opcode == 0x2C)
        {
            SetCurrentInstructionName(() => "SUB AL ib");
            _state.SetAL(_alu.Sub8(_state.GetAL(), NextUint8()));
        }
        if (opcode == 0x2D)
        {
            SetCurrentInstructionName(() => "SUB AX iw");
            _state.SetAX(_alu.Sub16(_state.GetAX(), NextUint16()));
        }
        if (opcode == 0x2E)
        {
            HandleInvalidOpcodeBecausePrefix(opcode);
        }
        if (opcode == 0x2F)
        {
            SetCurrentInstructionName(() => "DAS");
            int initialAL = _state.GetAL();
            bool initialCF = _state.GetCarryFlag();
            bool finalAuxillaryFlag = false;
            bool finalCarryFlag = false;
            _state.SetCarryFlag(false);
            if ((_state.GetAL() & 0x0F) > 9 || _state.GetAuxiliaryFlag())
            {
                _state.SetAL(_state.GetAL() - 6);
                finalCarryFlag = _state.GetCarryFlag() || initialCF;
                finalAuxillaryFlag = true;
            }
            if (initialAL > 0x99 || initialCF)
            {
                _state.SetAL(_state.GetAL() - 0x60);
                finalCarryFlag = true;
            }
            // Undocumented behaviour
            _alu.UpdateFlags8(_state.GetAL());
            _state.SetAuxiliaryFlag(finalAuxillaryFlag);
            _state.SetCarryFlag(finalCarryFlag);
        }
        if (opcode == 0x30)
        {
            SetCurrentInstructionName(() => "XOR rmb rb");
            _modRM.Read();
            _modRM.SetRm8(_alu.Xor8(_modRM.GetRm8(), _modRM.GetR8()));
        }
        if (opcode == 0x31)
        {
            SetCurrentInstructionName(() => "XOR rmw rw");
            _modRM.Read();
            _modRM.SetRm16(_alu.Xor16(_modRM.GetRm16(), _modRM.GetR16()));
        }
        if (opcode == 0x32)
        {
            SetCurrentInstructionName(() => "XOR rb rmb");
            _modRM.Read();
            _modRM.SetR8(_alu.Xor8(_modRM.GetR8(), _modRM.GetRm8()));
        }
        if (opcode == 0x33)
        {
            SetCurrentInstructionName(() => "XOR rw rmw");
            _modRM.Read();
            _modRM.SetR16(_alu.Xor16(_modRM.GetR16(), _modRM.GetRm16()));
        }
        if (opcode == 0x34)
        {
            SetCurrentInstructionName(() => "XOR AL mb");
            _state.SetAL(_alu.Xor8(_state.GetAL(), NextUint8()));
        }
        if (opcode == 0x35)
        {
            SetCurrentInstructionName(() => "XOR AX mw");
            _state.SetAX(_alu.Xor16(_state.GetAX(), NextUint16()));
        }
        if (opcode == 0x36)
            HandleInvalidOpcodeBecausePrefix(opcode);
        if (opcode == 0x37)
        {
            SetCurrentInstructionName(() => "AAA");
            bool finalAuxillaryFlag = false;
            bool finalCarryFlag = false;
            if ((_state.GetAL() & 0x0F) > 9 || _state.GetAuxiliaryFlag())
            {
                _state.SetAX(_state.GetAX() + 0x106);
                finalAuxillaryFlag = true;
                finalCarryFlag = true;
            }
            _state.SetAL(_state.GetAL() & 0x0F);
            // Undocumented behaviour
            _alu.UpdateFlags8(_state.GetAL());
            _state.SetAuxiliaryFlag(finalAuxillaryFlag);
            _state.SetCarryFlag(finalCarryFlag);
        }
        if (opcode == 0x38)
        {
            SetCurrentInstructionName(() => "CMP rmb rb");
            _modRM.Read();
            _alu.Sub8(_modRM.GetRm8(), _modRM.GetR8());
        }
        if (opcode == 0x39)
        {
            SetCurrentInstructionName(() => "CMP rmw rw");
            _modRM.Read();
            _alu.Sub16(_modRM.GetRm16(), _modRM.GetR16());
        }
        if (opcode == 0x3A)
        {
            SetCurrentInstructionName(() => "CMP rb rmb");
            _modRM.Read();
            _alu.Sub8(_modRM.GetR8(), _modRM.GetRm8());
        }
        if (opcode == 0x3B)
        {
            SetCurrentInstructionName(() => "CMP rw rmw");
            _modRM.Read();
            _alu.Sub16(_modRM.GetR16(), _modRM.GetRm16());
        }
        if (opcode == 0x3C)
        {
            SetCurrentInstructionName(() => "CMP AL ib");
            _alu.Sub8(_state.GetAL(), NextUint8());
        }
        if (opcode == 0x3D)
        {
            SetCurrentInstructionName(() => "CMP AX iw");
            _alu.Sub16(_state.GetAX(), NextUint16());
        }
        if (opcode == 0x3E)
        {
            HandleInvalidOpcodeBecausePrefix(opcode);
        }
        if (opcode == 0x3F)
        {
            SetCurrentInstructionName(() => "AAS");
            bool finalAuxillaryFlag = false;
            bool finalCarryFlag = false;
            if ((_state.GetAL() & 0x0F) > 9 || _state.GetAuxiliaryFlag())
            {
                _state.SetAX(_state.GetAX() - 6);
                _state.SetAH(_state.GetAH() - 1);
                finalAuxillaryFlag = true;
                finalCarryFlag = true;
            }
            _state.SetAL(_state.GetAL() & 0x0F);
            // Undocumented behaviour
            _alu.UpdateFlags8(_state.GetAL());
            _state.SetAuxiliaryFlag(finalAuxillaryFlag);
            _state.SetCarryFlag(finalCarryFlag);
        }
        if (opcode == 0x40 || opcode == 0x41 || opcode == 0x42 || opcode == 0x43 || opcode == 0x44 || opcode == 0x45 || opcode == 0x46 || opcode == 0x47)
        {
            int regIndex = opcode & REG_INDEX_MASK;
            SetCurrentInstructionName(() => $"INC {_state.GetRegisters().GetRegName(regIndex)}");
            _state.GetRegisters().SetRegister(regIndex, _alu.Inc16(_state.GetRegisters().GetRegister(regIndex)));
        }
        if (opcode == 0x48 || opcode == 0x49 || opcode == 0x4A || opcode == 0x4B || opcode == 0x4C || opcode == 0x4D || opcode == 0x4E || opcode == 0x4F)
        {
            int regIndex = opcode & REG_INDEX_MASK;
            SetCurrentInstructionName(() => $"DEC {_state.GetRegisters().GetRegName(regIndex)}");
            _state.GetRegisters().SetRegister(regIndex, _alu.Dec16(_state.GetRegisters().GetRegister(regIndex)));
        }
        if (opcode == 0x50 || opcode == 0x51 || opcode == 0x52 || opcode == 0x53 || opcode == 0x54 || opcode == 0x55 || opcode == 0x56 || opcode == 0x57)
        {
            int regIndex = opcode & REG_INDEX_MASK;
            SetCurrentInstructionName(() => $"PUSH {_state.GetRegisters().GetRegName(regIndex)}");
            _stack.Push(_state.GetRegisters().GetRegister(regIndex));
        }
        if (opcode == 0x58 || opcode == 0x59 || opcode == 0x5A || opcode == 0x5B || opcode == 0x5C || opcode == 0x5D || opcode == 0x5E || opcode == 0x5F)
        {
            int regIndex = opcode & REG_INDEX_MASK;
            SetCurrentInstructionName(() => $"POP {_state.GetRegisters().GetRegName(regIndex)}");
            _state.GetRegisters().SetRegister(regIndex, _stack.Pop());
        }
        if (opcode == 0x60)
        {
            // 80186
            SetCurrentInstructionName(() => "PUSHA");
            int sp = _state.GetSP();
            _stack.Push(_state.GetAX());
            _stack.Push(_state.GetCX());
            _stack.Push(_state.GetDX());
            _stack.Push(_state.GetBX());
            _stack.Push(sp);
            _stack.Push(_state.GetBP());
            _stack.Push(_state.GetSI());
            _stack.Push(_state.GetDI());
        }
        if (opcode == 0x61)
        {
            // 80186
            SetCurrentInstructionName(() => "POPA");
            _state.SetDI(_stack.Pop());
            _state.SetSI(_stack.Pop());
            _state.SetBP(_stack.Pop());
            // not restoring SP
            _stack.Pop();
            _state.SetBX(_stack.Pop());
            _state.SetDX(_stack.Pop());
            _state.SetCX(_stack.Pop());
            _state.SetAX(_stack.Pop());
        }
        if (opcode == 0x62 || opcode == 0x63 || opcode == 0x64 || opcode == 0x65 || opcode == 0x66 || opcode == 0x67) HandleInvalidOpcode(opcode);
        if (opcode == 0x68)
        {
            // 80186
            int value = NextUint16();
            SetCurrentInstructionName(() => $"PUSH {ConvertUtils.ToHex16(value)}");
            _stack.Push(value);
        }
        if (opcode == 0x69)
        {
            _modRM.Read();
            int value = NextUint16();
            SetCurrentInstructionName(() => $"IMUL16 rm16 {ConvertUtils.ToHex16(value)}");
            int result = _alu.Imul16(value, _modRM.GetRm16());
            _modRM.SetR16(result);
        }
        if (opcode == 0x6A)
        {
            // 80186
            // sign extend it to 16 bits
            ushort value = NextUint8();
            SetCurrentInstructionName(() => $"PUSH {ConvertUtils.ToHex16(value)}");
            _stack.Push(value);
        }
        if (opcode == 0x6B)
        {
            _modRM.Read();
            byte value = NextUint8();
            SetCurrentInstructionName(() => $"IMUL8 rm16 {ConvertUtils.ToHex16(value)}");
            int result = _alu.Imul16(value, _modRM.GetRm16());
            _modRM.SetR16(result);
        }
        if (opcode == 0x6C || opcode == 0x6D || opcode == 0x6E || opcode == 0x6F) // INSB, INSW, OUTSB, OUTSW
            ProcessString(opcode);
        if (opcode == 0x70 || opcode == 0x71 || opcode == 0x72 || opcode == 0x73 || opcode == 0x74 || opcode == 0x75 || opcode == 0x76 || opcode == 0x77 || opcode == 0x78 || opcode == 0x79 || opcode == 0x7A || opcode == 0x7B || opcode == 0x7C || opcode == 0x7D || opcode == 0x7E || opcode == 0x7F)
        {
            Jcc(opcode);
        }
        if (opcode == 0x80 || opcode == // GRP1 rmb ib, GRP1 rmw iw, GRP1 rmb ib, GRP1 rmw ib
                0x81 || opcode == 0x82 || opcode == 0x83) Grp1(opcode);
        if (opcode == 0x84)
        {
            SetCurrentInstructionName(() => "TEST rmb rb");
            _modRM.Read();
            _alu.And8(_modRM.GetRm8(), _modRM.GetR8());
        }
        if (opcode == 0x85)
        {
            SetCurrentInstructionName(() => "TEST rmw rw");
            _modRM.Read();
            _alu.And16(_modRM.GetRm16(), _modRM.GetR16());
        }
        if (opcode == 0x86)
        {
            SetCurrentInstructionName(() => "XCHG8");
            _modRM.Read();
            int value1 = _modRM.GetRm8();
            int value2 = _modRM.GetR8();
            _modRM.SetR8(value1);
            _modRM.SetRm8(value2);
        }
        if (opcode == 0x87)
        {
            SetCurrentInstructionName(() => "XCHG16");
            _modRM.Read();
            int value1 = _modRM.GetRm16();
            int value2 = _modRM.GetR16();
            _modRM.SetR16(value1);
            _modRM.SetRm16(value2);
        }
        if (opcode == 0x88)
        {
            SetCurrentInstructionName(() => "MOV rmb rb");
            _modRM.Read();
            _modRM.SetRm8(_modRM.GetR8());
        }
        if (opcode == 0x89)
        {
            SetCurrentInstructionName(() => "MOV rmw rw");
            _modRM.Read();
            _modRM.SetRm16((ushort)_modRM.GetR16());
        }
        if (opcode == 0x8A)
        {
            SetCurrentInstructionName(() => "MOV rb, rmb");
            _modRM.Read();
            _modRM.SetR8(_modRM.GetRm8());
        }
        if (opcode == 0x8B)
        {
            SetCurrentInstructionName(() => "MOV rw rmw");
            _modRM.Read();
            _modRM.SetR16(_modRM.GetRm16());
        }
        if (opcode == 0x8C)
        {
            SetCurrentInstructionName(() => "MOV rmw sreg");
            _modRM.Read();
            _modRM.SetRm16((ushort)_modRM.GetSegmentRegister());
        }
        if (opcode == 0x8D)
        {
            SetCurrentInstructionName(() => "LEA");
            _modRM.Read();
            _modRM.SetR16((ushort)_modRM.GetMemoryOffset());
        }
        if (opcode == 0x8E)
        {
            SetCurrentInstructionName(() => "MOV sreg rmw");
            _modRM.Read();
            _modRM.SetSegmentRegister(_modRM.GetRm16());
        }
        if (opcode == 0x8F)
        {
            SetCurrentInstructionName(() => "POP rmw");
            _modRM.Read();
            _modRM.SetRm16(_stack.Pop());
        }
        if (opcode == 0x90) SetCurrentInstructionName(() => "NOP");
        if (opcode == 0x91 || opcode == 0x92 || opcode == 0x93 || opcode == 0x94 || opcode == 0x95 || opcode == 0x96 || opcode == 0x97)
        {
            int regIndex = opcode & REG_INDEX_MASK;
            SetCurrentInstructionName(() => $"XCHG AX,{_state.GetRegisters().GetRegName(regIndex)}");
            int value1 = _state.GetAX();
            int value2 = _state.GetRegisters().GetRegister(regIndex);
            _state.SetAX(value2);
            _state.GetRegisters().SetRegister(regIndex, value1);
        }
        if (opcode == 0x98)
        {
            // Convert byte to word
            SetCurrentInstructionName(() => "CBW");
            _state.SetAX((byte)_state.GetAL());
        }
        if (opcode == 0x99)
        {
            // Sign extend AX into DX (word to dword)
            SetCurrentInstructionName(() => "CWD");
            if (_state.GetAX() >= 0x8000)
            {
                _state.SetDX(0xFFFF);
            }
            else
            {
                _state.SetDX(0);
            }
        }
        if (opcode == 0x9A)
        { // FAR CALL
            int ip = NextUint16();
            int cs = NextUint16();
            SetCurrentInstructionName(() => "FAR CALL");
            FarCall(_state.GetCS(), _internalIp, cs, ip);
        }
        // Do nothing, this is to wait for the FPU which is not implemented
        if (opcode == 0x9B)
        {
            SetCurrentInstructionName(() => "WAIT");
        }
        if (opcode == 0x9C)
        {
            SetCurrentInstructionName(() => "PUSHF");
            _stack.Push(_state.GetFlags().GetFlagRegister());
        }
        if (opcode == 0x9D)
        {
            SetCurrentInstructionName(() => "POPF");
            _state.GetFlags().SetFlagRegister(_stack.Pop());
        }
        if (opcode == 0x9E)
        {
            SetCurrentInstructionName(() => "SAHF");
            _state.GetFlags().SetFlagRegister(_state.GetAH());
        }
        if (opcode == 0x9F)
        {
            SetCurrentInstructionName(() => "LAHF");
            _state.SetAH(_state.GetFlags().GetFlagRegister());
        }
        if (opcode == 0xA0)
        {
            SetCurrentInstructionName(() => "MOV AL moffs8");
            _state.SetAL(_memory.GetUint8(GetDsNextUint16Address()));
            _staticAddressesRecorder.SetCurrentAddressOperation(ValueOperation.READ, OperandSize.Byte8);
        }
        if (opcode == 0xA1)
        {
            SetCurrentInstructionName(() => "MOV AX moffs16");
            _state.SetAX(_memory.GetUint16(GetDsNextUint16Address()));
            _staticAddressesRecorder.SetCurrentAddressOperation(ValueOperation.READ, OperandSize.Word16);
        }
        if (opcode == 0xA2)
        {
            SetCurrentInstructionName(() => "MOV moffs8 AL");
            _memory.SetUint8(GetDsNextUint16Address(), (byte)_state.GetAL());
            _staticAddressesRecorder.SetCurrentAddressOperation(ValueOperation.WRITE, OperandSize.Byte8);
        }
        if (opcode == 0xA3)
        {
            SetCurrentInstructionName(() => "MOV moffs16 AX");
            _memory.SetUint16(GetDsNextUint16Address(), (ushort)_state.GetAX());
            _staticAddressesRecorder.SetCurrentAddressOperation(ValueOperation.WRITE, OperandSize.Word16);
        }
        if (opcode == 0xA4 || opcode == 0xA5 || opcode == 0xA6 || opcode == 0xA7) ProcessString(opcode);
        if (opcode == 0xA8)
        {
            SetCurrentInstructionName(() => "TEST AL ib");
            _alu.And8(_state.GetAL(), NextUint8());
        }
        if (opcode == 0xA9)
        {
            SetCurrentInstructionName(() => "TEST AX iw");
            _alu.And16(_state.GetAX(), NextUint16());
        }
        if (opcode == 0xAA || opcode == 0xAB || opcode == 0xAC || opcode == 0xAD || opcode == 0xAE || opcode == 0xAF) ProcessString(opcode);
        if (opcode == 0xB0 || opcode == 0xB1 || opcode == 0xB2 || opcode == 0xB3 || opcode == 0xB4 || opcode == 0xB5 || opcode == 0xB6 || opcode == 0xB7)
        {
            int regIndex = opcode & REG_INDEX_MASK;
            SetCurrentInstructionName(() => $"MOV {_state.GetRegisters().GetReg8Name(regIndex)} ib");
            _state.GetRegisters().SetRegisterFromHighLowIndex8(regIndex, NextUint8());
        }
        if (opcode == 0xB8 || opcode == 0xB9 || opcode == 0xBA || opcode == 0xBB || opcode == 0xBC || opcode == 0xBD || opcode == 0xBE || opcode == 0xBF)
        {
            int regIndex = opcode & REG_INDEX_MASK;
            SetCurrentInstructionName(() => $"MOV {_state.GetRegisters().GetRegName(regIndex)} iw");
            _state.GetRegisters().SetRegister(regIndex, NextUint16());
        }
        if (opcode == 0xC0)
        {
            _modRM.Read();
            int count = this.NextUint8();
            int value = _modRM.GetRm8();
            SetCurrentInstructionName(() => $"SHL rmb {count}");
            _modRM.SetRm8(_alu.Shl8(value, count));
        }
        if (opcode == 0xC1)
        {
            _modRM.Read();
            int count = this.NextUint8();
            int value = _modRM.GetRm16();
            SetCurrentInstructionName(() => $"SHL rmw {count}");
            _modRM.SetRm16(_alu.Shl16(value, count));
        }
        if (opcode == 0xC2)
        {
            int numberOfBytesToPop = NextUint8();
            SetCurrentInstructionName(() => $"RET and pop {numberOfBytesToPop} bytes");
            NearRet(numberOfBytesToPop);
        }
        if (opcode == 0xC3)
        {
            SetCurrentInstructionName(() => "RET");
            NearRet(0);
        }
        if (opcode == 0xC4 || opcode == 0xC5)
        {
            // Copy segmented address that is in memory (32bits) into DS/ES and the
            // specified register
            _modRM.Read();
            _modRM.SetR16(_memory.GetUint16((int)_modRM.GetMemoryAddress()));
            int value = _memory.GetUint16((int)(_modRM.GetMemoryAddress() + 2));
            GetStaticAddressesRecorder().SetCurrentAddressOperation(ValueOperation.READ, OperandSize.Dword32);
            if (opcode == 0xC4)
            {
                // LES
                SetCurrentInstructionName(() => "LES rw md");
                _state.SetES(value);
            }
            else
            {
                // LDS
                SetCurrentInstructionName(() => "LDS rw md");
                _state.SetDS(value);
            }
        }
        if (opcode == 0xC6)
        {
            SetCurrentInstructionName(() => "MOV rmb ib");
            _modRM.Read();
            _modRM.SetRm8(NextUint8());
        }
        if (opcode == 0xC7)
        {
            SetCurrentInstructionName(() => "MOV rmw iw");
            _modRM.Read();
            _modRM.SetRm16(NextUint16());
        }
        if (opcode == 0xC8 || opcode == 0xC9) HandleInvalidOpcode(opcode);
        if (opcode == 0xCA)
        {
            int numberOfBytesToPop = NextUint8();
            SetCurrentInstructionName(() => $"RETF and pop {numberOfBytesToPop} bytes");
            FarRet(numberOfBytesToPop);
        }
        if (opcode == 0xCB)
        {
            SetCurrentInstructionName(() => "RETF");
            FarRet(0);
        }
        if (opcode == 0xCC)
        {
            SetCurrentInstructionName(() => "INT 3");
            Interrupt(3, false);
        }
        if (opcode == 0xCD)
        {
            SetCurrentInstructionName(() => "INT ib");
            Interrupt(NextUint8(), false);
        }
        if (opcode == 0xCE)
        {
            SetCurrentInstructionName(() => "INTO");
            if (_state.GetOverflowFlag())
            {
                Interrupt(4, false);
            }
        }
        if (opcode == 0xCF)
        {
            SetCurrentInstructionName(() => "IRET");
            InterruptRet();
        }
        if (opcode == 0xD0 || opcode == 0xD1 || opcode == 0xD2 || opcode == 0xD3) // GRP2 rmb 1, GRP2 rmw 1, GRP2 rmb CL, GRP2 rmw CL
        {
            Grp2(opcode);
        }
        if (opcode == 0xD4)
        {
            SetCurrentInstructionName(() => "AAM ib");
            int v1 = _state.GetAL();
            int v2 = NextUint8();
            if (v2 == 0)
            {
                HandleDivisionError();
                return;
            }
            int result = v1 % v2;
            _state.SetAH(v1 / v2);
            _state.SetAL(result);
            _alu.UpdateFlags8(result);
        }
        if (opcode == 0xD5)
        {
            SetCurrentInstructionName(() => "AAD ib");
            int result = (byte)(_state.GetAL() + (_state.GetAH() * NextUint8()));
            _state.SetAL(result);
            _state.SetAH(0);
            _state.GetFlags().SetFlagRegister(0);
            _alu.UpdateFlags8(result);
        }
        if (opcode == 0xD6) HandleInvalidOpcode(opcode);
        if (opcode == 0xD7)
        {
            SetCurrentInstructionName(() => "XLAT");
            int address = _modRM.GetAddress(SegmentRegisters.DsIndex, _state.GetBX()) + _state.GetAL();
            _state.SetAL(_memory.GetUint8(address));
        }
        if (opcode == 0xD8) HandleInvalidOpcode(opcode);
        if (opcode == 0xD9)
        {
            _modRM.Read();
            int groupIndex = _modRM.GetRegisterIndex();
            if (groupIndex == 0x7)
            {
                // Set the control word to the value expected after init since FPU is not supported.
                _modRM.SetRm16(0x37F);
                SetCurrentInstructionName(() => "FNSTCW");
            }
            else
            {
                throw new InvalidGroupIndexException(_machine, groupIndex);
            }
        }
        if (opcode == 0xDA)
        {
            HandleInvalidOpcode(opcode);
        }
        if (opcode == 0xDB)
        {
            int opCodeNextByte = NextUint8();
            if (opCodeNextByte != 0xE3)
            {
                int fullOpCode = (opcode << 8) | opCodeNextByte;
                HandleInvalidOpcode(fullOpCode);
            }
            SetCurrentInstructionName(() => "FNINIT");
            // Do nothing, no FPU emulation, but this is used to detect FPU
            if (opcode == 0xDC)
            { HandleInvalidOpcode(opcode); }
            if (opcode == 0xDD)
            {
                _modRM.Read();
                int groupIndex = _modRM.GetRegisterIndex();
                if (groupIndex == 0x7)
                {
                    // Set non zero, means no FPU installed when called after FNINIT.
                    _modRM.SetRm16(0xFF);
                    SetCurrentInstructionName(() => "FNSTSW");
                }
                else
                {
                    throw new InvalidGroupIndexException(_machine, groupIndex);
                }
            }
        }
        if (opcode == 0xDE || opcode == 0xDF) HandleInvalidOpcode(opcode);
        if (opcode == 0xE0 || opcode == 0xE1)
        { // LOOPZ / LOOPNZ
            bool zeroFlag = (opcode & 0x1) == 1;
            byte address = NextUint8();
            if (zeroFlag)
            {
                SetCurrentInstructionName(() => $"LOOPZ {address}");
            }
            else
            {
                SetCurrentInstructionName(() => $"LOOPNZ {address}");
            }
            int cx = _state.GetCX() - 1;
            _state.SetCX(cx);
            if (cx != 0 && _state.GetZeroFlag() == zeroFlag)
            {
                _internalIp += address;
            }
        }
        if (opcode == 0xE2)
        { // LOOP
            SetCurrentInstructionName(() => "LOOP");
            byte address = NextUint8();
            int cx = _state.GetCX() - 1;
            _state.SetCX(cx);
            if (cx != 0)
            {
                _internalIp += address;
            }
        }
        if (opcode == 0xE3) // JCXZ
            Jcc(opcode);
        if (opcode == 0xE4)
        {
            int port = NextUint8();
            SetCurrentInstructionName(() => $"IN AL {ConvertUtils.ToHex8(port)}");
            _state.SetAL(Inb(port));
        }
        if (opcode == 0xE5)
        {
            int port = NextUint16();
            SetCurrentInstructionName(() => $"IN AL {ConvertUtils.ToHex16(port)}");
            _state.SetAX(Inw(port));
        }
        if (opcode == 0xE6)
        {
            int port = NextUint8();
            int value = _state.GetAL();
            SetCurrentInstructionName(() => $"OUT {ConvertUtils.ToHex8(port)} AL={ConvertUtils.ToHex8(value)}");
            Outb(port, value);
        }
        if (opcode == 0xE7)
        {
            int port = NextUint16();
            int value = _state.GetAX();
            SetCurrentInstructionName(() => $"OUT {ConvertUtils.ToHex16(port)} AX={ConvertUtils.ToHex16(value)}");
            Outw(port, value);
        }
        if (opcode == 0xE8)
        {
            SetCurrentInstructionName(() => "CALL NEAR");
            int nextInstruction = _internalIp + 2;
            short offset = (short)NextUint16();
            ushort callAddress = (ushort)(nextInstruction + offset);
            NearCall(nextInstruction, callAddress);
        }
        if (opcode == 0xE9)
        {
            short offset = (short)NextUint16();
            JumpNear(_internalIp + offset);
        }
        if (opcode == 0xEA)
        {
            int ip = NextUint16();
            int cs = NextUint16();
            JumpFar(cs, ip);
        }
        if (opcode == 0xEB)
        {
            byte offset = NextUint8();
            JumpNear(_internalIp + offset);
        }
        if (opcode == 0xEC)
        {
            int port = _state.GetDX();
            SetCurrentInstructionName(() => "IN AL DX=" + ConvertUtils.ToHex16(port));
            _state.SetAL(Inb(port));
        }
        if (opcode == 0xED)
        {
            int port = _state.GetDX();
            SetCurrentInstructionName(() => "IN AX DX=" + ConvertUtils.ToHex16(port));
            _state.SetAX(Inw(port));
        }
        if (opcode == 0xEE)
        {
            int port = _state.GetDX();
            int value = _state.GetAL();
            SetCurrentInstructionName(() => "OUT DX=" + ConvertUtils.ToHex16(port) + " AL=" + ConvertUtils.ToHex8(value));
            Outb(port, value);
        }
        if (opcode == 0xEF)
        {
            int port = _state.GetDX();
            int value = _state.GetAX();
            SetCurrentInstructionName(() => "OUT DX=" + ConvertUtils.ToHex16(port) + " AX=" + ConvertUtils.ToHex16(value));
            Outw(port, value);
        }
        if (opcode == 0xF0 || opcode == 0xF1) HandleInvalidOpcode(opcode);
        if (opcode == 0xF2 || opcode == 0xF3) HandleInvalidOpcodeBecausePrefix(opcode);
        if (opcode == 0xF4)
        {
            SetCurrentInstructionName(() => "HLT");
            _logger.Information("HLT instruction encountered, halting!");
            _running = false;
        }
        if (opcode == 0xF5)
        {
            SetCurrentInstructionName(() => "CMC");
            _state.SetCarryFlag(!_state.GetCarryFlag());
        }
        if (opcode == 0xF6) // GRP3a rmb
            Grp3a();
        if (opcode == 0xF7) // GRP3b rmw
            Grp3b();
        if (opcode == 0xF8)
        {
            SetCurrentInstructionName(() => "CLC");
            _state.SetCarryFlag(false);
        }
        if (opcode == 0xF9)
        {
            SetCurrentInstructionName(() => "STC");
            _state.SetCarryFlag(true);
        }
        if (opcode == 0xFA)
        {
            SetCurrentInstructionName(() => "CLI");
            _state.SetInterruptFlag(false);
        }
        if (opcode == 0xFB)
        {
            SetCurrentInstructionName(() => "STI");
            _state.SetInterruptFlag(true);
        }
        if (opcode == 0xFC)
        {
            SetCurrentInstructionName(() => "CLD");
            _state.SetDirectionFlag(false);
        }
        if (opcode == 0xFD)
        {
            SetCurrentInstructionName(() => "STD");
            _state.SetDirectionFlag(true);
        }
        if (opcode == 0xFE)
        {// GRP4 rmb
            Grp4();
        }
        if (opcode == 0xFF)
        { // GRP5 rmw
            Grp5();
        }
        HandleInvalidOpcode(opcode);
    }

    private void Grp3a()
    {
        _modRM.Read();
        int groupIndex = _modRM.GetRegisterIndex();
        if (groupIndex == 0)
        {
            SetCurrentInstructionName(() => "TEST8");
            _alu.And8(_modRM.GetRm8(), NextUint8());
        }
        if (groupIndex == 2)
        {
            SetCurrentInstructionName(() => "NOT8");
            _modRM.SetRm8((byte)~_modRM.GetRm8());
        }
        if (groupIndex == 3)
        {
            SetCurrentInstructionName(() => "NEG8");
            int value = _modRM.GetRm8();
            value = _alu.Sub8(0, value);
            _modRM.SetRm8(value);
            _state.SetCarryFlag(value != 0);
        }
        if (groupIndex == 4)
        {
            SetCurrentInstructionName(() => "MUL8");
            int result = _alu.Mul8(_state.GetAL(), _modRM.GetRm8());
            // Upper part of the result goes in AH
            _state.SetAH((byte)(result >> 8));
            _state.SetAL((byte)result);
        }
        if (groupIndex == 5)
        {
            SetCurrentInstructionName(() => "IMUL8");
            int result = _alu.Imul8(_state.GetAL(), _modRM.GetRm8());
            // Upper part of the result goes in AH
            _state.SetAH((byte)(result >> 8));
            _state.SetAL((byte)result);
        }
        if (groupIndex == 6)
        {
            SetCurrentInstructionName(() => "DIV8");
            int v1 = _state.GetAX();
            int v2 = _modRM.GetRm8();
            int? result = _alu.Div8(v1, v2);
            if (result == null)
            {
                HandleDivisionError();
                return;
            }
            _state.SetAL(result.Value);
            _state.SetAH(v1 % v2);
        }
        if (groupIndex == 7)
        {
            SetCurrentInstructionName(() => "IDIV8");
            int v1 = (short)_state.GetAX();
            int v2 = (sbyte)_modRM.GetRm8();
            int? result = _alu.Idiv8(v1, v2);
            if (result == null)
            {
                HandleDivisionError();
                return;
            }
            _state.SetAL(result.Value);
            _state.SetAH(((short)v1) % ((sbyte)v2));
        }
        throw new InvalidGroupIndexException(_machine, groupIndex);
    }

    private void ProcessRep(int opcode)
    {
        // repeat while zero flag is false for REPNZ (last bit is 0)
        // or while zero flag is true for REPZ (last bit is 1)
        var continueZeroFlagValue = _state.GetContinueZeroFlagValue();
        // For some instructions, zero flag is not to be checked
        bool checkZeroFlag = IsStringOpUpdatingFlags(opcode);
        int cx = _state.GetCX();
        while (cx != 0)
        {
            // re-set the segment override that may have been cleared. No need to reset ip
            // as string instructions don't modify it and are only one byte.
            ProcessString(opcode);
            cx = cx - 1;

            if (_logger.IsEnabled(Serilog.Events.LogEventLevel.Verbose))
            {
                _logger.Verbose("{@Rep} Loop, {@Cx}, {@If}, {@CheckZeroFlag}, {@ContinueZF}",
                _state.GetCurrentInstructionNameWithPrefix(),
                ConvertUtils.ToHex(cx), _state.GetZeroFlag(), checkZeroFlag, continueZeroFlagValue);
            }
            // Not all the string operations require checking the zero flag...
            if (checkZeroFlag && _state.GetZeroFlag() != continueZeroFlagValue)
            {
                break;
            }
        }
        _state.SetCX(cx);
    }

    private int GetMemoryAddressOverridableDsSi() => _modRM.GetAddress(SegmentRegisters.DsIndex, _state.GetSI());

    private int GetMemoryAddressEsDi() => MemoryUtils.ToPhysicalAddress(_state.GetES(), _state.GetDI());

    private void ProcessString(int opcode)
    {
        int diff = (_state.GetDirectionFlag() ? -1 : 1) << (opcode & 1);

        if (opcode == 0xA4)
        {
            SetCurrentInstructionName(() => "MOVSB");
            int value = _memory.GetUint8(GetMemoryAddressOverridableDsSi());
            _memory.SetUint8(GetMemoryAddressEsDi(), (byte)value);
            _state.SetSI(_state.GetSI() + diff);
            _state.SetDI(_state.GetDI() + diff);
        }
        if (opcode == 0xA5)
        {
            SetCurrentInstructionName(() => "MOVSW");
            int value = _memory.GetUint16(GetMemoryAddressOverridableDsSi());
            _memory.SetUint16(GetMemoryAddressEsDi(), (ushort)value);
            _state.SetSI(_state.GetSI() + diff);
            _state.SetDI(_state.GetDI() + diff);
        }
        if (opcode == 0xA6)
        {
            SetCurrentInstructionName(() => "CMPSB");
            int value = _memory.GetUint8(GetMemoryAddressOverridableDsSi());
            _alu.Sub8(value, _memory.GetUint8(GetMemoryAddressEsDi()));
            _state.SetSI(_state.GetSI() + diff);
            _state.SetDI(_state.GetDI() + diff);
        }
        if (opcode == 0xA7)
        {
            SetCurrentInstructionName(() => "CMPSW");
            int value = _memory.GetUint16(GetMemoryAddressOverridableDsSi());
            _alu.Sub16(value, _memory.GetUint16(GetMemoryAddressEsDi()));
            _state.SetSI(_state.GetSI() + diff);
            _state.SetDI(_state.GetDI() + diff);
        }
        if (opcode == 0xAA)
        {
            SetCurrentInstructionName(() => "STOSB");
            _memory.SetUint8(GetMemoryAddressEsDi(), (byte)_state.GetAL());
            _state.SetDI(_state.GetDI() + diff);
        }
        if (opcode == 0xAB)
        {
            SetCurrentInstructionName(() => "STOSW");
            _memory.SetUint16(GetMemoryAddressEsDi(), (ushort)_state.GetAX());
            _state.SetDI(_state.GetDI() + diff);
        }
        if (opcode == 0xAC)
        {
            SetCurrentInstructionName(() => "LODSB");
            int value = _memory.GetUint8(GetMemoryAddressOverridableDsSi());
            _state.SetAL(value);
            _state.SetSI(_state.GetSI() + diff);
        }
        if (opcode == 0xAD)
        {
            SetCurrentInstructionName(() => "LODSW");
            int value = _memory.GetUint16(GetMemoryAddressOverridableDsSi());
            _state.SetAX(value);
            _state.SetSI(_state.GetSI() + diff);
        }
        if (opcode == 0xAE)
        {
            SetCurrentInstructionName(() => "SCASB");
            _alu.Sub8(_state.GetAL(), _memory.GetUint8(GetMemoryAddressEsDi()));
            _state.SetDI(_state.GetDI() + diff);
        }
        if (opcode == 0xAF)
        {
            SetCurrentInstructionName(() => "SCASW");
            _alu.Sub16(_state.GetAX(), _memory.GetUint16(GetMemoryAddressEsDi()));
            _state.SetDI(_state.GetDI() + diff);
        }
        if (opcode == 0x6C)
        {
            SetCurrentInstructionName(() => "INSB");
            int port = _state.GetDX();
            int value = Inb(port);
            _memory.SetUint8(GetMemoryAddressEsDi(), (byte)value);
            _state.SetSI(_state.GetSI() + diff);
        }
        if (opcode == 0x6D)
        {
            SetCurrentInstructionName(() => "INSW");
            int port = _state.GetDX();
            int value = Inw(port);
            _memory.SetUint16(GetMemoryAddressEsDi(), (ushort)value);
            _state.SetSI(_state.GetSI() + diff);
        }
        if (opcode == 0x6E)
        {
            SetCurrentInstructionName(() => "OUTSB");
            int port = _state.GetDX();
            int value = _memory.GetUint8(GetMemoryAddressOverridableDsSi());
            Outb(port, value);
            _state.SetSI(_state.GetSI() + diff);
        }
        if (opcode == 0x6F)
        {
            SetCurrentInstructionName(() => "OUTSW");
            int port = _state.GetDX();
            int value = _memory.GetUint16(GetMemoryAddressOverridableDsSi());
            Outw(port, value);
            _state.SetSI(_state.GetSI() + diff);
        }
        HandleInvalidOpcode(opcode);
    }

    private void Outb(int port, int val)
    {
        if (_ioPortDispatcher != null)
        {
            _ioPortDispatcher.Outb((ushort)port, (byte)val);
        }
    }

    private void Outw(int port, int val)
    {
        if (_ioPortDispatcher != null)
        {
            _ioPortDispatcher.Outw((ushort)port, (ushort)val);
        }
    }

    private byte Inb(int port)
    {
        if (_ioPortDispatcher != null)
        {
            return (byte)_ioPortDispatcher.Inb((ushort)port);
        }
        return 0;
    }

    private ushort Inw(int port)
    {
        if (_ioPortDispatcher != null)
        {
            return (ushort)_ioPortDispatcher.Inw((ushort)port);
        }
        return 0;
    }

    private void HandleInvalidOpcodeBecausePrefix(int opcode) => throw new InvalidOpCodeException(_machine, opcode, true);

    private void HandleInvalidOpcode(int opcode) => throw new InvalidOpCodeException(_machine, opcode, false);

    private void Interrupt(int? vectorNumber, bool external)
    {
        if (vectorNumber == null) { return; }
        int targetIP = _memory.GetUint16(4 * vectorNumber.Value);
        int targetCS = _memory.GetUint16(4 * vectorNumber.Value + 2);
        if (_errorOnUninitializedInterruptHandler && targetCS == 0 && targetIP == 0)
        {
            throw new UnhandledOperationException(_machine,
                $"Int was called but vector was not initialized for vectorNumber={ConvertUtils.ToHex(vectorNumber.Value)}");
        }
        int returnCS = _state.GetCS();
        int returnIP = _internalIp;
        if (IsLoggingEnabled())
        {
            _logger.Debug("int {@VectorNumber} handler found in memory, {@SegmentedAddressRepresentation}", ConvertUtils.ToHex(vectorNumber.Value),
                ConvertUtils.ToSegmentedAddressRepresentation(targetCS, targetIP));
        }
        _stack.Push(_state.GetFlags().GetFlagRegister());
        _stack.Push(returnCS);
        _stack.Push(returnIP);
        _state.SetInterruptFlag(false);
        _internalIp = targetIP;
        _state.SetCS(targetCS);
        var recordReturn = true;
        if (external)
        {
            _functionHandlerInUse = _functionHandlerInExternalInterrupt;
            recordReturn = false;
        }
        _functionHandlerInUse.Icall(CallType.INTERRUPT, targetCS, targetIP, returnCS, returnIP, vectorNumber.Value,
            recordReturn);
    }

    private static bool IsStringOpUpdatingFlags(int stringOpCode)
        => stringOpCode == 0xA6 // CMPSB
        || stringOpCode == 0xA7 // CMPSW
        || stringOpCode == 0xAE // SCASB
        || stringOpCode == 0xAF; // SCASW

    private int ProcessPrefixes()
    {
        int opcode = NextUint8();
        while (IsPrefix(opcode))
        {
            ProcessPrefix(opcode);
            opcode = NextUint8();
        }
        return opcode;
    }

    private void ProcessPrefix(int opcode)
    {
        if (opcode == 0x26)
        {
            AddCurrentInstructionPrefix(() => "ES:");
            _state.SetSegmentOverrideIndex(SegmentRegisters.EsIndex);
        }
        if (opcode == 0x2E)
        {
            AddCurrentInstructionPrefix(() => "CS:");
            _state.SetSegmentOverrideIndex(SegmentRegisters.CsIndex);
        }
        if (opcode == 0x36)
        {
            AddCurrentInstructionPrefix(() => "SS:");
            _state.SetSegmentOverrideIndex(SegmentRegisters.SsIndex);
        }
        if (opcode == 0x3E)
        {
            AddCurrentInstructionPrefix(() => "DS:");
            _state.SetSegmentOverrideIndex(SegmentRegisters.DsIndex);
        }
        if (opcode == 0x64)
        {
            AddCurrentInstructionPrefix(() => "FS:");
            _state.SetSegmentOverrideIndex(SegmentRegisters.FsIndex);
        }
        if (opcode == 0x65)
        {
            AddCurrentInstructionPrefix(() => "GS:");
            _state.SetSegmentOverrideIndex(SegmentRegisters.GsIndex);
        }
        if (opcode == 0xF0)
        {
            AddCurrentInstructionPrefix(() => "LOCK");
        }
        if (opcode == 0xF2 || opcode == 0xF3)
        { // REPNZ, REPZ
            bool continueZeroFlagValue = (opcode & 1) == 1;
            _state.SetContinueZeroFlagValue(continueZeroFlagValue);
            AddCurrentInstructionPrefix(() => "REP" + (continueZeroFlagValue ? "Z" : ""));
        }
        throw new InvalidVMOperationException(_machine,
            $"processPrefix Called with a non prefix opcode {opcode}");
    }

    private bool IsPrefix(int opcode) => PREFIXES_OPCODES.Contains(opcode);

    private void HandleExternalInterrupt()
    {
        if (_externalInterruptVectorNumber == null || !_state.GetInterruptFlag())
        {
            return;
        }
        if (IsLoggingEnabled())
        {
            _logger.Debug("Interrupted!, {@ExternalInterruptVectorNumber}", _externalInterruptVectorNumber);
        }
        Interrupt(_externalInterruptVectorNumber, true);
        _externalInterruptVectorNumber = null;
    }

    private bool IsStringOpcode(int opcode)
    {
        return STRING_OPCODES.Contains(opcode);
    }

    public void FarRet(int numberOfBytesToPop)
    {
        _functionHandlerInUse.Ret(CallType.FAR);
        _internalIp = _stack.Pop();
        _state.SetCS(_stack.Pop());
        _state.SetSP(numberOfBytesToPop + _state.GetSP());
    }

    public StaticAddressesRecorder GetStaticAddressesRecorder() => _staticAddressesRecorder;

    public void InterruptRet()
    {
        _functionHandlerInUse.Ret(CallType.INTERRUPT);
        _internalIp = _stack.Pop();
        _state.SetCS(_stack.Pop());
        _state.GetFlags().SetFlagRegister(_stack.Pop());
        _functionHandlerInUse = _functionHandler;
    }

    private int GetDsNextUint16Address()
    {
        return _modRM.GetAddress(SegmentRegisters.DsIndex, NextUint16(), true);
    }

    private int GetRm8Or16(bool op1Byte)
    {
        if (op1Byte)
        {
            return _modRM.GetRm8();
        }
        return _modRM.GetRm16();
    }

    private void HandleDivisionError()
    {
        // Reset IP because instruction is not finished (this is how an actual CPU behaves)
        _internalIp = _state.GetIP();
        Interrupt(0, false);
    }

    /// <summary>
    /// Jumps handling
    /// </summary>
    private void Jcc(int opcode)
    {
        byte address = NextUint8();
        bool jump = opcode switch
        {
            0x70 => _state.GetOverflowFlag(),
            0x71 => !_state.GetOverflowFlag(),
            0x72 => _state.GetCarryFlag(),
            0x73 => !_state.GetCarryFlag(),
            0x74 => _state.GetZeroFlag(),
            0x75 => !_state.GetZeroFlag(),
            0x76 => _state.GetCarryFlag() || _state.GetZeroFlag(),
            0x77 => !_state.GetCarryFlag() && !_state.GetZeroFlag(),
            0x78 => _state.GetSignFlag(),
            0x79 => !_state.GetSignFlag(),
            0x7A => _state.GetParityFlag(),
            0x7B => !_state.GetParityFlag(),
            0x7C => _state.GetSignFlag() != _state.GetOverflowFlag(),
            0x7D => _state.GetSignFlag() == _state.GetOverflowFlag(),
            0x7E => _state.GetZeroFlag() || _state.GetSignFlag() != _state.GetOverflowFlag(),
            0x7F => !_state.GetZeroFlag() && _state.GetSignFlag() == _state.GetOverflowFlag(),
            0xE3 => _state.GetCX() == 0,
            _ => throw new InvalidOpCodeException(_machine, opcode, false)
        };
        SetCurrentInstructionName(() => opcode switch
        {
            0x70 => "JO",
            0x71 => "JNO",
            0x72 => "JB",
            0x73 => "JNB",
            0x74 => "JZ",
            0x75 => "JNZ",
            0x76 => "JBE",
            0x77 => "JA",
            0x78 => "JS",
            0x79 => "JNS",
            0x7A => "JP",
            0x7B => "JPO",
            0x7C => "JL",
            0x7D => "JGE",
            0x7E => "JNG",
            0x7F => "JG",
            0xE3 => "JCXZ",
            _ => ""
        } + " " + address + " jump?" + jump);
        if (jump)
        {
            _internalIp += address;
        }
    }

    private void Grp1(int opcode)
    {
        _modRM.Read();
        int groupIndex = _modRM.GetRegisterIndex();
        bool op1Byte = (opcode & 0b01) == 0;
        bool op2Byte = (opcode & 0b11) != 1;
        int op2;
        if (op2Byte)
        {
            if (op1Byte)
            {
                op2 = NextUint8();
            }
            else
            {
                // preserve sign in byte so that it can be extended later if needed
                op2 = (ushort)(sbyte)NextUint8();
            }
        }
        else
        {
            op2 = NextUint16();
        }
        int op1 = GetRm8Or16(op1Byte);
        SetCurrentInstructionName(() => GenerateGrp1Name(groupIndex, op1Byte, op1, op2));
        int res;
        if (op1Byte)
        {
            res = (groupIndex) switch
            {
                0 => _alu.Add8(op1, op2),
                1 => _alu.Or8(op1, op2),
                2 => _alu.Adc8(op1, op2),
                3 => _alu.Sbb8(op1, op2),
                4 => _alu.And8(op1, op2),
                5 => _alu.Sub8(op1, op2),
                6 => _alu.Xor8(op1, op2),
                7 => _alu.Sub8(op1, op2),
                _ => throw new InvalidGroupIndexException(_machine, groupIndex)
            };
        }
        else
        {
            res = (groupIndex) switch
            {
                0 => _alu.Add16(op1, op2),
                1 => _alu.Or16(op1, op2),
                2 => _alu.Adc16(op1, op2),
                3 => _alu.Sbb16(op1, op2),
                4 => _alu.And16(op1, op2),
                5 => _alu.Sub16(op1, op2),
                6 => _alu.Xor16(op1, op2),
                7 => _alu.Sub16(op1, op2),
                _ => throw new InvalidGroupIndexException(_machine, groupIndex)
            };
        }
        // 7 is CMP so no memory to set
        if (groupIndex != 7)
        {
            if (op1Byte)
            {
                _modRM.SetRm8(res);
            }
            else
            {
                _modRM.SetRm16(res);
            }
        }
    }

    private string GenerateGrp1Name(int groupIndex, bool op1Byte, int op1, int op2)
    {
        var opName = (groupIndex) switch
        {
            0 => "ADD",
            1 => "OR",
            2 => "ADC",
            3 => "SBB",
            4 => "AND",
            5 => "SUB",
            6 => "XOR",
            7 => "CMP",
            _ => "",
        };
        return opName + Generate8Or16Value(op1Byte, op1, op2);
    }

    private void Grp2(int opcode)
    {
        // GRP2 rmb 1
        _modRM.Read();
        int groupIndex = _modRM.GetRegisterIndex();
        bool op1Byte = (opcode & 0b01) == 0;

        bool valueIsCL = (opcode & 0b10) == 0b10;// if it 0b10, it is CL
        int op2;
        if (valueIsCL)
        {
            op2 = _state.GetCL();
        }
        else
        {
            op2 = 1;
        }
        int op1 = GetRm8Or16(op1Byte);
        SetCurrentInstructionName(() => GenerateGrp2Name(groupIndex, op1Byte, op1, op2));
        int res;
        if (op1Byte)
        {
            res = (groupIndex) switch
            {
                0 => _alu.Rol8(op1, op2),
                1 => _alu.Ror8(op1, op2),
                2 => _alu.Rcl8(op1, op2),
                3 => _alu.Rcr8(op1, op2),
                4 => _alu.Shl8(op1, op2),
                5 => _alu.Shr8(op1, op2),
                7 => _alu.Sar8(op1, op2),
                _ => throw new InvalidGroupIndexException(_machine, groupIndex)
            };
        }
        else
        {
            res = (groupIndex) switch
            {
                0 => _alu.Rol16(op1, op2),
                1 => _alu.Ror16(op1, op2),
                2 => _alu.Rcl16(op1, op2),
                3 => _alu.Rcr16(op1, op2),
                4 => _alu.Shl16(op1, op2),
                5 => _alu.Shr16(op1, op2),
                7 => _alu.Sar16(op1, op2),
                _ => throw new InvalidGroupIndexException(_machine, groupIndex)
            };
        }
        if (op1Byte)
        {
            _modRM.SetRm8(res);
        }
        else
        {
            _modRM.SetRm16(res);
        }
    }

    private string GenerateGrp2Name(int groupIndex, bool op1Byte, int op1, int op2)
    {
        var opName = (groupIndex) switch
        {
            0 => "ROL",
            1 => "ROR",
            2 => "RCL",
            3 => "RCR",
            4 => "SHL",
            5 => "SHR",
            7 => "SAR",
            _ => ""
        };
        return opName + Generate8Or16Value(op1Byte, op1, op2);
    }

    private string Generate8Or16Value(bool op1Byte, int op1, int op2)
    {
        var @params = $"({ConvertUtils.ToHex8(op1)},{ConvertUtils.ToHex8(op2)})";
        if (op1Byte)
        {
            return $"8 {@params}";
        }
        return $"16 {@params}";
    }

    private void Grp3b()
    {
        _modRM.Read();
        int groupIndex = _modRM.GetRegisterIndex();
        if (groupIndex == 0)
        {
            SetCurrentInstructionName(() => "TEST16");
            _alu.And16(_modRM.GetRm16(), NextUint16());
        }
        if (groupIndex == 2)
        {
            SetCurrentInstructionName(() => "NOT16");
            _modRM.SetRm16((ushort)~_modRM.GetRm16());
        }
        if (groupIndex == 3)
        {
            SetCurrentInstructionName(() => "NEG16");
            int value = _modRM.GetRm16();
            value = _alu.Sub16(0, value);
            _modRM.SetRm16(value);
            _state.SetCarryFlag(value != 0);
        }
        if (groupIndex == 4)
        {
            SetCurrentInstructionName(() => "MUL16");
            int result = _alu.Mul16(_state.GetAX(), _modRM.GetRm16());
            // Upper part of the result goes in DX
            _state.SetDX((ushort)(result >> 16));
            _state.SetAX(result);
        }
        if (groupIndex == 5)
        {
            SetCurrentInstructionName(() => "IMUL16");
            int result = _alu.Imul16(_state.GetAX(), _modRM.GetRm16());
            // Upper part of the result goes in DX
            _state.SetDX((ushort)(result >> 16));
            _state.SetAX(result);
        }
        if (groupIndex == 6)
        {
            SetCurrentInstructionName(() => "DIV16");
            int v1 = (_state.GetDX() << 16) | _state.GetAX();
            int v2 = _modRM.GetRm16();
            int? result = _alu.Div16(v1, v2);
            if (result == null)
            {
                HandleDivisionError();
                return;
            }
            _state.SetAX(result.Value);
            _state.SetDX((int)((uint)v1 % (uint)v2));
        }
        if (groupIndex == 7)
        {
            SetCurrentInstructionName(() => "IDIV16");
            // no sign extension for v1 as it is already a 32bit value
            int v1 = (_state.GetDX() << 16) | _state.GetAX();
            int v2 = (short)_modRM.GetRm16();
            int? result = _alu.Idiv16(v1, v2);
            if (result == null)
            {
                HandleDivisionError();
                return;
            }
            _state.SetAX(result.Value);
            _state.SetDX(v1 % v2);
        }
        throw new InvalidGroupIndexException(_machine, groupIndex);
    }

    private void Grp4()
    {
        _modRM.Read();
        int groupIndex = _modRM.GetRegisterIndex();
        if (groupIndex == 0)
        {
            SetCurrentInstructionName(() => "INC");
            _modRM.SetRm8(_alu.Inc8(_modRM.GetRm8()));
        }
        if (groupIndex == 1)
        {
            SetCurrentInstructionName(() => "DEC");
            _modRM.SetRm8(_alu.Dec8(_modRM.GetRm8()));
        }
        if (groupIndex == 7)
        {
            // Callback, emulator specific instruction FE38 like in dosbox,
            // to allow interrupts to be overridden by the program
            Callback(NextUint16());
        }
        throw new InvalidGroupIndexException(_machine, groupIndex);
    }

    private void Grp5()
    {
        _modRM.Read();
        int groupIndex = _modRM.GetRegisterIndex();
        if (groupIndex == 0)
        {
            SetCurrentInstructionName(() => "INC");
            _modRM.SetRm16(_alu.Inc16(_modRM.GetRm16()));
        }
        if (groupIndex == 1)
        {
            SetCurrentInstructionName(() => "DEC");
            _modRM.SetRm16(_alu.Dec16(_modRM.GetRm16()));
        }
        if (groupIndex == 2)
        {
            SetCurrentInstructionName(() => "NEAR CALL");
            int callAddress = _modRM.GetRm16();
            NearCall(_internalIp, callAddress);
        }
        if (groupIndex == 3)
        {
            SetCurrentInstructionName(() => "FAR CALL");
            int? ipAddress = _modRM.GetMemoryAddress();
            if (ipAddress is null) { return; }
            GetStaticAddressesRecorder().SetCurrentAddressOperation(ValueOperation.READ, OperandSize.Dword32Ptr);
            int ip = _memory.GetUint16(ipAddress.Value);
            int cs = _memory.GetUint16(ipAddress.Value + 2);
            FarCall(_state.GetCS(), _internalIp, cs, ip);
        }
        if (groupIndex == 4)
        {
            int ip = _modRM.GetRm16();
            JumpNear(ip);
        }
        if (groupIndex == 5)
        {
            int? ipAddress = _modRM.GetMemoryAddress();
            if (ipAddress is null) { return; }
            GetStaticAddressesRecorder().SetCurrentAddressOperation(ValueOperation.READ, OperandSize.Dword32Ptr);
            int ip = _memory.GetUint16(ipAddress.Value);
            int cs = _memory.GetUint16(ipAddress.Value + 2);
            JumpFar(cs, ip);
        }
        if (groupIndex == 6)
        {
            SetCurrentInstructionName(() => "PUSH");
            _stack.Push(_modRM.GetRm16());
        }
        throw new InvalidGroupIndexException(_machine, groupIndex);
    }

    private void JumpNear(int ip)
    {
        SetCurrentInstructionName(
            () => $"JMP NEAR {ConvertUtils.ToSegmentedAddressRepresentation(_state.GetCS(), ip)}");
        HandleJump(_state.GetCS(), ip);
    }

    private void JumpFar(int cs, int ip)
    {
        SetCurrentInstructionName(
            () => $"JMP FAR {ConvertUtils.ToSegmentedAddressRepresentation(cs, ip)}");
        HandleJump(cs, ip);
    }

    private void HandleJump(int cs, int ip)
    {
        _internalIp = ip;
        _state.SetCS(cs);
    }

    private void NearCall(int returnIP, int callIP)
    {
        _stack.Push(returnIP);
        _internalIp = callIP;
        HandleCall(CallType.NEAR, _state.GetCS(), returnIP, _state.GetCS(), callIP);
    }

    private void FarCall(int returnCS, int returnIP, int targetCS, int targetIP)
    {
        _stack.Push(returnCS);
        _stack.Push(returnIP);
        _state.SetCS(targetCS);
        _internalIp = targetIP;
        HandleCall(CallType.FAR, returnCS, returnIP, targetCS, targetIP);
    }

    private void HandleCall(CallType callType, int returnCS, int returnIP, int targetCS, int targetIP)
    {
        if (IsLoggingEnabled())
        {
            _logger.Debug("CALL {@TargetCsTargetIp}, will return to {@ReturnCsReturnIp}", ConvertUtils.ToSegmentedAddressRepresentation(targetCS, targetIP),
              ConvertUtils.ToSegmentedAddressRepresentation(returnCS, returnIP));
        }
        _functionHandlerInUse.Call(callType, targetCS, targetIP, returnCS, returnIP);
    }

    public void NearRet(int numberOfBytesToPop)
    {
        _functionHandlerInUse.Ret(CallType.NEAR);
        _internalIp = _stack.Pop();
        _state.SetSP(numberOfBytesToPop + _state.GetSP());
    }

    public byte NextUint8()
    {
        var res = _memory.GetUint8(GetInternalIpPhysicalAddress());
        _internalIp++;
        return res;
    }

    public void SetFlagOnInterruptStack(int flagMask, bool flagValue)
    {
        int flagsAddress = MemoryUtils.ToPhysicalAddress(_state.GetSS(), _state.GetSP() + 4);
        int value = _memory.GetUint16(flagsAddress);
        if (flagValue)
        {
            value = value | flagMask;
        }
        else
        {
            value = value & ~flagMask;
        }
        _memory.SetUint16(flagsAddress, (ushort)value);
    }

    private void Callback(int callbackIndex)
    {
        SetCurrentInstructionName(() => $"CALLBACK {callbackIndex}");
        if (IsLoggingEnabled())
        {
            _logger.Debug("callback {@CallbackIndex}", ConvertUtils.ToHex16(callbackIndex));
        }
        _callbackHandler.Run(callbackIndex);
    }

    public ushort NextUint16()
    {
        var res = _memory.GetUint16(GetInternalIpPhysicalAddress());
        _internalIp += 2;
        return res;
    }

    private int GetInternalIpPhysicalAddress() => MemoryUtils.ToPhysicalAddress(_state.GetCS(), _internalIp);
}