namespace Spice86.Emulator.Cpu;

using Serilog;

using Spice86.Emulator.Callback;
using Spice86.Emulator.Function;
using Spice86.Emulator.IOPorts;
using Spice86.Emulator.Machine;
using Spice86.Emulator.Memory;

using System;

/// <summary>
/// Implementation of a 8086 CPU. <br /> It has some 80186, 80286 and 80386 instructions as some
/// program use them. <br /> It also has some x87 FPU instructions to support telling the programs
/// that x87 is not supported :) <br /> Some docs that helped the implementation: <ul> <li>
/// Instructions decoding: http://rubbermallet.org/8086%20notes.pdf and
/// http://ref.x86asm.net/coder32.html </li><li> Instructions implementation details:
/// https://www.felixcloutier.com/x86/ </li><li> Pure 8086 instructions:
/// https://jbwyatt.com/253/emu/8086_instruction_set.html </li></ul>
/// TODO: Complete it !
/// </summary>
public class Cpu
{

    private static readonly ILogger _logger = Log.Logger.ForContext<Cpu>();

    private Machine _machine;
    private State _state;
    private Memory _memory;
    private ModRM _modRM;
    private Alu _alu;
    private Stack _stack;
    private CallbackHandler _callbackHandler;
    private IOPortDispatcher _ioPortDispatcher;
    private FunctionHandler _functionHandler;
    private FunctionHandler _functionHandlerInExternalInterrupt;
    private FunctionHandler _functionHandlerInUse;
    private StaticAddressesRecorder _staticAddressesRecorder;
    // Value used to read parts of the instruction.
    // CPU uses this internally and adjusts IP after instruction execution is done.
    private int _internalIp;
    private bool _running = true;
    // interrupt not generated by the code
    private int _externalInterruptVectorNumber;
    // When true will crash if an interrupt targets code at 0000:0000
    private bool _errorOnUninitializedInterruptHandler;
    private Boolean _forceLog;

    public Cpu(Machine machine, bool debugMode)
    {
        _machine = machine;
        _memory = machine.GetMemory();
        _state = new State();
        _alu = new Alu(_state);
        _stack = new Stack(_memory, _state);
        _functionHandler = new FunctionHandler(machine, debugMode);
        _functionHandlerInExternalInterrupt = new FunctionHandler(machine, debugMode);
        _functionHandlerInUse = _functionHandler;
        _staticAddressesRecorder = new StaticAddressesRecorder(_state, debugMode);
        _modRM = new ModRM(machine, this);
    }

    public State GetState()
    {
        return _state;
    }

    public Alu GetAlu()
    {
        return _alu;
    }
    public Stack GetStack()
    {
        return _stack;
    }

    internal void ExternalInterrupt(int vectorNumber)
    {
        throw new NotImplementedException();
    }

    internal void FarRet(int v)
    {
        throw new NotImplementedException();
    }



    internal StaticAddressesRecorder GetStaticAddressesRecorder()
    {
        throw new NotImplementedException();
    }

    internal void InterruptRet()
    {
        throw new NotImplementedException();
    }

    internal void NearRet(int v)
    {
        throw new NotImplementedException();
    }

    public byte NextUint8()
    {
        var res = _memory.GetUint8(GetInternalIpPhysicalAddress());
        _internalIp++;
        return res;
    }

    public ushort NextUint16()
    {
        var res = _memory.GetUint16(GetInternalIpPhysicalAddress());
        _internalIp += 2;
        return res;
    }

    private int GetInternalIpPhysicalAddress()
    {
        return MemoryUtils.ToPhysicalAddress(_state.GetCS(), _internalIp);
    }
}
