namespace Spice86.Emulator.CPU;

using Serilog;

using Spice86.Emulator.Callback;
using Spice86.Emulator.Errors;
using Spice86.Emulator.Function;
using Spice86.Emulator.IOPorts;
using Spice86.Emulator.VM;
using Spice86.Emulator.Memory;
using Spice86.Utils;

using System;
using System.Collections.Generic;
using System.Linq;

/// <summary>
/// Implementation of a 8086 CPU. <br /> It has some 80186, 80286 and 80386 instructions as some
/// program use them. <br /> It also has some x87 FPU instructions to support telling the programs
/// that x87 is not supported :) <br /> Some docs that helped the implementation: <ul> <li>
/// Instructions decoding: http://rubbermallet.org/8086%20notes.pdf and
/// http://ref.x86asm.net/coder32.html </li><li> Instructions implementation details:
/// https://www.felixcloutier.com/x86/ </li><li> Pure 8086 instructions:
/// https://jbwyatt.com/253/emu/8086_instruction_set.html </li></ul>
/// TODO: Fix it !
/// </summary>
public class Cpu {

    // Extract regIndex from opcode
    private const int REG_INDEX_MASK = 0b111;

    private static readonly ILogger _logger = Log.Logger.ForContext<Cpu>();
    private static readonly List<int> PREFIXES_OPCODES = new[] { 0x26, 0x2E, 0x36, 0x3E, 0x64, 0x65, 0xF0, 0xF2, 0xF3 }.ToList();
    private static readonly List<int> STRING_OPCODES = new[] { 0xA4, 0xA5, 0xA6, 0xA7, 0xAA, 0xAB, 0xAC, 0xAD, 0xAE, 0xAF, 0x6C, 0x6D, 0x6E, 0x6F }.ToList();

    private readonly Alu _alu;
    private readonly FunctionHandler _functionHandler;
    private readonly FunctionHandler _functionHandlerInExternalInterrupt;
    private readonly Machine _machine;
    private readonly Memory _memory;
    private readonly ModRM _modRM;
    private readonly Stack _stack;
    private readonly State _state;
    private readonly StaticAddressesRecorder _staticAddressesRecorder;
    private CallbackHandler? _callbackHandler;

    // When true will crash if an interrupt targets code at 0000:0000
    private bool _errorOnUninitializedInterruptHandler;

    // interrupt not generated by the code
    private byte? _externalInterruptVectorNumber;

    private bool? _forceLog;
    private FunctionHandler _functionHandlerInUse;

    // Value used to read parts of the instruction.
    // CPU uses this internally and adjusts IP after instruction execution is done.
    private ushort _internalIp;

    private IOPortDispatcher? _ioPortDispatcher;
    private bool _running = true;
    public StaticAddressesRecorder GetStaticAddresRecorder => _staticAddressesRecorder;

    public bool IsRunning => _running;

    public Cpu(Machine machine, bool debugMode) {
        _machine = machine;
        _memory = machine.GetMemory();
        _state = new State();
        _alu = new Alu(_state);
        _stack = new Stack(_memory, _state);
        _functionHandler = new FunctionHandler(machine, debugMode);
        _functionHandlerInExternalInterrupt = new FunctionHandler(machine, debugMode);
        _functionHandlerInUse = _functionHandler;
        _staticAddressesRecorder = new StaticAddressesRecorder(_state, debugMode);
        _modRM = new ModRM(machine, this);
    }

    public void ExecuteNextInstruction() {
        _internalIp = _state.GetIP();
        _staticAddressesRecorder.Reset();
        String stateString = "";
        if (IsLoggingEnabled()) {
            stateString = _state.ToString();
            _state.ResetCurrentInstructionPrefix();
            _state.SetCurrentInstructionName("");
        }
        byte opcode = ProcessPrefixes();
        if (IsLoggingEnabled()) {
            _logger.Debug("Before execution: {@OpCode} {@StateString} ", ConvertUtils.ToHex8(opcode),
                stateString);
        }
        if (_state.GetContinueZeroFlagValue() != null && IsStringOpcode(opcode)) {
            // continueZeroFlag is either true or false if a rep prefix has been encountered
            ProcessRep(opcode);
        } else {
            ExecOpcode(opcode);
        }
        if (IsLoggingEnabled()) {
            String instructionName = _state.GetCurrentInstructionNameWithPrefix();
            _logger.Debug("After execution of {@InstructionName} {@State}", instructionName, _state);
        }
        _state.ClearPrefixes();
        _staticAddressesRecorder.Commit();
        _state.IncCycles();
        HandleExternalInterrupt();
        _state.SetIP(_internalIp);
    }

    public void ExternalInterrupt(byte vectorNumber) {
        // hack: do not let the timer overwrite keyboard.
        if (_externalInterruptVectorNumber == null || _externalInterruptVectorNumber != 9) {
            _externalInterruptVectorNumber = vectorNumber;
        }
    }

    public void FarRet(ushort numberOfBytesToPop) {
        _functionHandlerInUse.Ret(CallType.FAR);
        _internalIp = _stack.Pop();
        _state.SetCS(_stack.Pop());
        _state.SetSP((ushort)(numberOfBytesToPop + _state.GetSP()));
    }

    public Alu GetAlu() => _alu;

    public FunctionHandler GetFunctionHandler() => _functionHandler;

    public FunctionHandler GetFunctionHandlerInExternalInterrupt() => _functionHandlerInExternalInterrupt;

    public FunctionHandler GetFunctionHandlerInUse() => _functionHandlerInUse;

    public Stack GetStack() => _stack;

    public State GetState() => _state;

    public StaticAddressesRecorder GetStaticAddressesRecorder() => _staticAddressesRecorder;

    public void InterruptRet() {
        _functionHandlerInUse.Ret(CallType.INTERRUPT);
        _internalIp = _stack.Pop();
        _state.SetCS(_stack.Pop());
        _state.GetFlags().SetFlagRegister(_stack.Pop());
        _functionHandlerInUse = _functionHandler;
    }

    public void NearRet(int numberOfBytesToPop) {
        _functionHandlerInUse.Ret(CallType.NEAR);
        _internalIp = _stack.Pop();
        _state.SetSP((ushort)(numberOfBytesToPop + _state.GetSP()));
    }

    public ushort NextUint16() {
        var res = _memory.GetUint16(GetInternalIpPhysicalAddress());
        _internalIp += 2;
        return res;
    }

    public byte NextUint8() {
        var res = _memory.GetUint8(GetInternalIpPhysicalAddress());
        _internalIp++;
        return res;
    }

    public void SetCallbackHandler(CallbackHandler callbackHandler) => _callbackHandler = callbackHandler;

    public void SetErrorOnUninitializedInterruptHandler(bool errorOnUninitializedInterruptHandler) {
        _errorOnUninitializedInterruptHandler = errorOnUninitializedInterruptHandler;
    }

    public void SetFlagOnInterruptStack(int flagMask, bool flagValue) {
        uint flagsAddress = MemoryUtils.ToPhysicalAddress(_state.GetSS(), (ushort)(_state.GetSP() + 4));
        int value = _memory.GetUint16(flagsAddress);
        if (flagValue) {
            value = value | flagMask;
        } else {
            value = value & ~flagMask;
        }
        _memory.SetUint16(flagsAddress, (ushort)value);
    }

    public void SetForceLog(bool forceLog) => _forceLog = forceLog;

    public void SetIoPortDispatcher(IOPortDispatcher? iOPortDispatcher) => _ioPortDispatcher = iOPortDispatcher;

    public void SetRunning(bool running) => _running = running;

    private static bool IsStringOpUpdatingFlags(int stringOpCode)
        => stringOpCode == 0xA6 // CMPSB
            || stringOpCode == 0xA7 // CMPSW
            || stringOpCode == 0xAE // SCASB
            || stringOpCode == 0xAF;

    private void AddCurrentInstructionPrefix(Func<String> getLog) {
        // Optimization, do not calculate the log if it is not used
        if (IsLoggingEnabled()) {
            _state.AddCurrentInstructionPrefix(getLog.Invoke());
        }
    }

    private void Callback(ushort callbackIndex) {
        SetCurrentInstructionName(() => $"CALLBACK {callbackIndex}");
        if (IsLoggingEnabled()) {
            _logger.Debug("callback {@CallbackIndex}", ConvertUtils.ToHex16(callbackIndex));
        }
        _callbackHandler?.Run(callbackIndex);
    }

    private void ExecOpcode(byte opcode) {
        int regIndex;
        switch (opcode) {
            case 0x00:
                SetCurrentInstructionName(() => "ADD rmb rb");
                _modRM.Read();
                _modRM.SetRm8(_alu.Add8(_modRM.GetRm8(), _modRM.GetR8()));
                break;

            case 0x01:
                SetCurrentInstructionName(() => "ADD rmw rw");
                _modRM.Read();
                _modRM.SetRm16(_alu.Add16(_modRM.GetRm16(), _modRM.GetR16()));
                break;

            case 0x02:
                SetCurrentInstructionName(() => "ADD rb rmb");
                _modRM.Read();
                _modRM.SetR8(_alu.Add8(_modRM.GetR8(), _modRM.GetRm8()));
                break;

            case 0x03:
                SetCurrentInstructionName(() => "ADD rw rmw");
                _modRM.Read();
                _modRM.SetR16(_alu.Add16(_modRM.GetR16(), _modRM.GetRm16()));
                break;

            case 0x04:
                SetCurrentInstructionName(() => "ADD AL ib");
                _state.SetAL(_alu.Add8(_state.GetAL(), NextUint8()));
                break;

            case 0x05:
                SetCurrentInstructionName(() => "ADD AX iw");
                _state.SetAX(_alu.Add16(_state.GetAX(), NextUint16()));
                break;

            case 0x06:
                SetCurrentInstructionName(() => "PUSH ES");
                _stack.Push(_state.GetES());
                break;

            case 0x07:
                SetCurrentInstructionName(() => "POP ES");
                _state.SetES(_stack.Pop());
                break;

            case 0x08:
                SetCurrentInstructionName(() => "OR rmb rb");
                _modRM.Read();
                _modRM.SetRm8(_alu.Or8(_modRM.GetRm8(), _modRM.GetR8()));
                break;

            case 0x09:
                SetCurrentInstructionName(() => "OR rmw rw");
                _modRM.Read();
                _modRM.SetRm16(_alu.Or16(_modRM.GetRm16(), _modRM.GetR16()));
                break;

            case 0x0A:
                SetCurrentInstructionName(() => "OR rb rmb");
                _modRM.Read();
                _modRM.SetR8(_alu.Or8(_modRM.GetR8(), _modRM.GetRm8()));
                break;

            case 0x0B:
                SetCurrentInstructionName(() => "OR rw rmw");
                _modRM.Read();
                _modRM.SetR16(_alu.Or16(_modRM.GetR16(), _modRM.GetRm16()));
                break;

            case 0x0C:
                SetCurrentInstructionName(() => "OR AL ib");
                _state.SetAL(_alu.Or8(_state.GetAL(), NextUint8()));
                break;

            case 0x0D:
                SetCurrentInstructionName(() => "OR AX iw");
                _state.SetAX(_alu.Or16(_state.GetAX(), NextUint16()));
                break;

            case 0x0E:
                SetCurrentInstructionName(() => "PUSH CS");
                _stack.Push(_state.GetCS());
                break;

            case 0x0F:
                HandleInvalidOpcode(opcode);
                break;

            case 0x10:
                SetCurrentInstructionName(() => "ADC rmb rb");
                _modRM.Read();
                _modRM.SetRm8(_alu.Adc8(_modRM.GetRm8(), _modRM.GetR8()));
                break;

            case 0x11:
                SetCurrentInstructionName(() => "ADC rmw rw");
                _modRM.Read();
                _modRM.SetRm16(_alu.Adc16(_modRM.GetRm16(), _modRM.GetR16()));
                break;

            case 0x12:
                SetCurrentInstructionName(() => "ADC rb rmb");
                _modRM.Read();
                _modRM.SetR8(_alu.Adc8(_modRM.GetR8(), _modRM.GetRm8()));
                break;

            case 0x13:
                SetCurrentInstructionName(() => "ADC rw rmw");
                _modRM.Read();
                _modRM.SetR16(_alu.Adc16(_modRM.GetR16(), _modRM.GetRm16()));
                break;

            case 0x14:
                SetCurrentInstructionName(() => "ADC AL ib");
                _state.SetAL(_alu.Adc8(_state.GetAL(), NextUint8()));
                break;

            case 0x15:
                SetCurrentInstructionName(() => "ADC AX iw");
                _state.SetAX(_alu.Adc16(_state.GetAX(), NextUint16()));
                break;

            case 0x16:
                SetCurrentInstructionName(() => "PUSH SS");
                _stack.Push(_state.GetSS());
                break;

            case 0x17:
                SetCurrentInstructionName(() => "POP SS");
                _state.SetSS(_stack.Pop());
                break;

            case 0x18:
                SetCurrentInstructionName(() => "SBB rmb rb");
                _modRM.Read();
                _modRM.SetRm8(_alu.Sbb8(_modRM.GetRm8(), _modRM.GetR8()));
                break;

            case 0x19:
                SetCurrentInstructionName(() => "SBB rmw rw");
                _modRM.Read();
                _modRM.SetRm16(_alu.Sbb16(_modRM.GetRm16(), _modRM.GetR16()));
                break;

            case 0x1A:
                SetCurrentInstructionName(() => "SBB rb rmb");
                _modRM.Read();
                _modRM.SetR8(_alu.Sbb8(_modRM.GetR8(), _modRM.GetRm8()));
                break;

            case 0x1B:
                SetCurrentInstructionName(() => "SBB rw rmw");
                _modRM.Read();
                _modRM.SetR16(_alu.Sbb16(_modRM.GetR16(), _modRM.GetRm16()));
                break;

            case 0x1C:
                SetCurrentInstructionName(() => "SBB AL ib");
                _state.SetAL(_alu.Sbb8(_state.GetAL(), NextUint8()));
                break;

            case 0x1D:
                SetCurrentInstructionName(() => "SBB AX iw");
                _state.SetAX(_alu.Sbb16(_state.GetAX(), NextUint16()));
                break;

            case 0x1E:
                SetCurrentInstructionName(() => "PUSH DS");
                _stack.Push(_state.GetDS());
                break;

            case 0x1F:
                SetCurrentInstructionName(() => "POP DS");
                _state.SetDS(_stack.Pop());
                break;

            case 0x20:
                SetCurrentInstructionName(() => "AND rmb rb");
                _modRM.Read();
                _modRM.SetRm8(_alu.And8(_modRM.GetRm8(), _modRM.GetR8()));
                break;

            case 0x21:
                SetCurrentInstructionName(() => "AND rmw rw");
                _modRM.Read();
                _modRM.SetRm16(_alu.And16(_modRM.GetRm16(), _modRM.GetR16()));
                break;

            case 0x22:
                SetCurrentInstructionName(() => "AND rb rmb");
                _modRM.Read();
                _modRM.SetR8(_alu.And8(_modRM.GetR8(), _modRM.GetRm8()));
                break;

            case 0x23:
                SetCurrentInstructionName(() => "AND rw rmw");
                _modRM.Read();
                _modRM.SetR16(_alu.And16(_modRM.GetR16(), _modRM.GetRm16()));
                break;

            case 0x24:
                SetCurrentInstructionName(() => "AND AL ib");
                _state.SetAL(_alu.And8(_state.GetAL(), NextUint8()));
                break;

            case 0x25:
                SetCurrentInstructionName(() => "AND AX iw");
                _state.SetAX(_alu.And16(_state.GetAX(), NextUint16()));
                break;

            case 0x26:
                HandleInvalidOpcodeBecausePrefix(opcode);
                break;

            case 0x27: {
                SetCurrentInstructionName(() => "DAA");
                byte initialAL = _state.GetAL();
                bool initialCF = _state.GetCarryFlag();
                bool finalAuxillaryFlag = false;
                if ((_state.GetAL() & 0x0F) > 9 || _state.GetAuxiliaryFlag()) {
                    _state.SetAL((byte)(_state.GetAL() + 6));
                    finalAuxillaryFlag = true;
                }
                bool finalCarryFlag;
                if (initialAL > 0x99 || initialCF) {
                    _state.SetAL((byte)(_state.GetAL() + 0x60));
                    finalCarryFlag = true;
                } else {
                    finalCarryFlag = false;
                }
                // Undocumented behaviour
                _alu.UpdateFlags8(_state.GetAL());
                _state.SetAuxiliaryFlag(finalAuxillaryFlag);
                _state.SetCarryFlag(finalCarryFlag);
                break;
            }
            case 0x28:
                SetCurrentInstructionName(() => "SUB rmb rb");
                _modRM.Read();
                _modRM.SetRm8(_alu.Sub8(_modRM.GetRm8(), _modRM.GetR8()));
                break;

            case 0x29:
                SetCurrentInstructionName(() => "SUB rmw rw");
                _modRM.Read();
                _modRM.SetRm16(_alu.Sub16(_modRM.GetRm16(), _modRM.GetR16()));
                break;

            case 0x2A:
                SetCurrentInstructionName(() => "SUB rb rmb");
                _modRM.Read();
                _modRM.SetR8(_alu.Sub8(_modRM.GetR8(), _modRM.GetRm8()));
                break;

            case 0x2B:
                SetCurrentInstructionName(() => "SUB rw rmw");
                _modRM.Read();
                _modRM.SetR16(_alu.Sub16(_modRM.GetR16(), _modRM.GetRm16()));
                break;

            case 0x2C:
                SetCurrentInstructionName(() => "SUB AL ib");
                _state.SetAL(_alu.Sub8(_state.GetAL(), NextUint8()));
                break;

            case 0x2D:
                SetCurrentInstructionName(() => "SUB AX iw");
                _state.SetAX(_alu.Sub16(_state.GetAX(), NextUint16()));
                break;

            case 0x2E:
                HandleInvalidOpcodeBecausePrefix(opcode);
                break;

            case 0x2F: {
                SetCurrentInstructionName(() => "DAS");
                byte initialAL = _state.GetAL();
                bool initialCF = _state.GetCarryFlag();
                bool finalAuxillaryFlag = false;
                bool finalCarryFlag = false;
                _state.SetCarryFlag(false);
                if ((_state.GetAL() & 0x0F) > 9 || _state.GetAuxiliaryFlag()) {
                    _state.SetAL((byte)(_state.GetAL() - 6));
                    finalCarryFlag = _state.GetCarryFlag() || initialCF;
                    finalAuxillaryFlag = true;
                }
                if (initialAL > 0x99 || initialCF) {
                    _state.SetAL((byte)(_state.GetAL() - 0x60));
                    finalCarryFlag = true;
                }
                // Undocumented behaviour
                _alu.UpdateFlags8(_state.GetAL());
                _state.SetAuxiliaryFlag(finalAuxillaryFlag);
                _state.SetCarryFlag(finalCarryFlag);
                break;
            }
            case 0x30:
                SetCurrentInstructionName(() => "XOR rmb rb");
                _modRM.Read();
                _modRM.SetRm8(_alu.Xor8(_modRM.GetRm8(), _modRM.GetR8()));
                break;

            case 0x31:
                SetCurrentInstructionName(() => "XOR rmw rw");
                _modRM.Read();
                _modRM.SetRm16(_alu.Xor16(_modRM.GetRm16(), _modRM.GetR16()));
                break;

            case 0x32:
                SetCurrentInstructionName(() => "XOR rb rmb");
                _modRM.Read();
                _modRM.SetR8(_alu.Xor8(_modRM.GetR8(), _modRM.GetRm8()));
                break;

            case 0x33:
                SetCurrentInstructionName(() => "XOR rw rmw");
                _modRM.Read();
                _modRM.SetR16(_alu.Xor16(_modRM.GetR16(), _modRM.GetRm16()));
                break;

            case 0x34:
                SetCurrentInstructionName(() => "XOR AL mb");
                _state.SetAL(_alu.Xor8(_state.GetAL(), NextUint8()));
                break;

            case 0x35:
                SetCurrentInstructionName(() => "XOR AX mw");
                _state.SetAX(_alu.Xor16(_state.GetAX(), NextUint16()));
                break;

            case 0x36:
                HandleInvalidOpcodeBecausePrefix(opcode);
                break;

            case 0x37: {
                SetCurrentInstructionName(() => "AAA");
                bool finalAuxillaryFlag = false;
                bool finalCarryFlag = false;
                if ((_state.GetAL() & 0x0F) > 9 || _state.GetAuxiliaryFlag()) {
                    _state.SetAX((ushort)(_state.GetAX() + 0x106));
                    finalAuxillaryFlag = true;
                    finalCarryFlag = true;
                }
                _state.SetAL((byte)(_state.GetAL() & 0x0F));
                // Undocumented behaviour
                _alu.UpdateFlags8(_state.GetAL());
                _state.SetAuxiliaryFlag(finalAuxillaryFlag);
                _state.SetCarryFlag(finalCarryFlag);
                break;
            }
            case 0x38:
                SetCurrentInstructionName(() => "CMP rmb rb");
                _modRM.Read();
                _alu.Sub8(_modRM.GetRm8(), _modRM.GetR8());
                break;

            case 0x39:
                SetCurrentInstructionName(() => "CMP rmw rw");
                _modRM.Read();
                _alu.Sub16(_modRM.GetRm16(), _modRM.GetR16());
                break;

            case 0x3A:
                SetCurrentInstructionName(() => "CMP rb rmb");
                _modRM.Read();
                _alu.Sub8(_modRM.GetR8(), _modRM.GetRm8());
                break;

            case 0x3B:
                SetCurrentInstructionName(() => "CMP rw rmw");
                _modRM.Read();
                _alu.Sub16(_modRM.GetR16(), _modRM.GetRm16());
                break;

            case 0x3C:
                SetCurrentInstructionName(() => "CMP AL ib");
                _alu.Sub8(_state.GetAL(), NextUint8());
                break;

            case 0x3D:
                SetCurrentInstructionName(() => "CMP AX iw");
                _alu.Sub16(_state.GetAX(), NextUint16());
                break;

            case 0x3E:
                HandleInvalidOpcodeBecausePrefix(opcode);
                break;

            case 0x3F: {
                SetCurrentInstructionName(() => "AAS");
                bool finalAuxillaryFlag = false;
                bool finalCarryFlag = false;
                if ((_state.GetAL() & 0x0F) > 9 || _state.GetAuxiliaryFlag()) {
                    _state.SetAX((ushort)(_state.GetAX() - 6));
                    _state.SetAH((byte)(_state.GetAH() - 1));
                    finalAuxillaryFlag = true;
                    finalCarryFlag = true;
                }
                _state.SetAL((byte)(_state.GetAL() & 0x0F));
                // Undocumented behaviour
                _alu.UpdateFlags8(_state.GetAL());
                _state.SetAuxiliaryFlag(finalAuxillaryFlag);
                _state.SetCarryFlag(finalCarryFlag);
                break;
            }
            case 0x40:
            case 0x41:
            case 0x42:
            case 0x43:
            case 0x44:
            case 0x45:
            case 0x46:
            case 0x47:
                regIndex = opcode & REG_INDEX_MASK;
                SetCurrentInstructionName(() => $"INC {_state.GetRegisters().GetRegName(regIndex)}");
                _state.GetRegisters().SetRegister(regIndex, _alu.Inc16(_state.GetRegisters().GetRegister(regIndex)));
                break;

            case 0x48:
            case 0x49:
            case 0x4A:
            case 0x4B:
            case 0x4C:
            case 0x4D:
            case 0x4E:
            case 0x4F:
                regIndex = opcode & REG_INDEX_MASK;
                SetCurrentInstructionName(() => $"DEC {_state.GetRegisters().GetRegName(regIndex)}");
                _state.GetRegisters().SetRegister(regIndex, _alu.Dec16(_state.GetRegisters().GetRegister(regIndex)));
                break;

            case 0x50:
            case 0x51:
            case 0x52:
            case 0x53:
            case 0x54:
            case 0x55:
            case 0x56:
            case 0x57:
                regIndex = opcode & REG_INDEX_MASK;
                SetCurrentInstructionName(() => $"PUSH {_state.GetRegisters().GetRegName(regIndex)}");
                _stack.Push(_state.GetRegisters().GetRegister(regIndex));
                break;

            case 0x58:
            case 0x59:
            case 0x5A:
            case 0x5B:
            case 0x5C:
            case 0x5D:
            case 0x5E:
            case 0x5F:
                regIndex = opcode & REG_INDEX_MASK;
                SetCurrentInstructionName(() => $"POP {_state.GetRegisters().GetRegName(regIndex)}");
                _state.GetRegisters().SetRegister(regIndex, _stack.Pop());
                break;

            case 0x60:
                // 80186
                SetCurrentInstructionName(() => "PUSHA");
                ushort sp = _state.GetSP();
                _stack.Push(_state.GetAX());
                _stack.Push(_state.GetCX());
                _stack.Push(_state.GetDX());
                _stack.Push(_state.GetBX());
                _stack.Push(sp);
                _stack.Push(_state.GetBP());
                _stack.Push(_state.GetSI());
                _stack.Push(_state.GetDI());
                break;

            case 0x61:
                // 80186
                SetCurrentInstructionName(() => "POPA");
                _state.SetDI(_stack.Pop());
                _state.SetSI(_stack.Pop());
                _state.SetBP(_stack.Pop());
                // not restoring SP
                _stack.Pop();
                _state.SetBX(_stack.Pop());
                _state.SetDX(_stack.Pop());
                _state.SetCX(_stack.Pop());
                _state.SetAX(_stack.Pop());
                break;

            case 0x62:
            case 0x63:
            case 0x64:
            case 0x65:
            case 0x66:
            case 0x67:
                HandleInvalidOpcode(opcode);
                break;
            case 0x68: {
                // 80186
                ushort value = NextUint16();
                SetCurrentInstructionName(() => $"PUSH {ConvertUtils.ToHex16(value)}");
                _stack.Push(value);
                break;
            }
            case 0x69: {
                _modRM.Read();
                short value = (short)NextUint16();
                SetCurrentInstructionName(() => $"IMUL16 rm16 {ConvertUtils.ToHex16((ushort)value)}");
                int result = _alu.Imul16(value, (short)_modRM.GetRm16());
                _modRM.SetR16((ushort)result);
                break;
            }
            case 0x6A: {
                // 80186
                // sign extend it to 16 bits
                short signedValue = (sbyte)NextUint8();
                ushort value = (ushort)signedValue;
                SetCurrentInstructionName(() => $"PUSH {ConvertUtils.ToHex16(value)}");
                _stack.Push(value);
                break;
            }
            case 0x6B: {
                _modRM.Read();
                byte value = NextUint8();
                SetCurrentInstructionName(() => $"IMUL16 rm16 {ConvertUtils.ToHex8(value)}");
                int result = _alu.Imul16(value, (short)_modRM.GetRm16());
                _modRM.SetR16((ushort)result);
                break;
            }
            case 0x6C:
            case 0x6D:
            case 0x6E:
            case 0x6F: // INSB, INSW, OUTSB, OUTSW
                ProcessString(opcode);
                break;

            case 0x70:
            case 0x71:
            case 0x72:
            case 0x73:
            case 0x74:
            case 0x75:
            case 0x76:
            case 0x77:
            case 0x78:
            case 0x79:
            case 0x7A:
            case 0x7B:
            case 0x7C:
            case 0x7D:
            case 0x7E:
            case 0x7F:
                Jcc(opcode);
                break;

            case 0x80: // GRP1 rmb ib, GRP1 rmw iw, GRP1 rmb ib, GRP1 rmw ib
            case 0x81:
            case 0x82:
            case 0x83:
                Grp1(opcode);
                break;

            case 0x84:
                SetCurrentInstructionName(() => "TEST rmb rb");
                _modRM.Read();
                _alu.And8(_modRM.GetRm8(), _modRM.GetR8());
                break;

            case 0x85:
                SetCurrentInstructionName(() => "TEST rmw rw");
                _modRM.Read();
                _alu.And16(_modRM.GetRm16(), _modRM.GetR16());
                break;

            case 0x86: {
                SetCurrentInstructionName(() => "XCHG8");
                _modRM.Read();
                byte value1 = _modRM.GetRm8();
                byte value2 = _modRM.GetR8();
                _modRM.SetR8(value1);
                _modRM.SetRm8(value2);
                break;
            }
            case 0x87: {
                SetCurrentInstructionName(() => "XCHG16");
                _modRM.Read();
                ushort value1 = _modRM.GetRm16();
                ushort value2 = _modRM.GetR16();
                _modRM.SetR16(value1);
                _modRM.SetRm16(value2);
                break;
            }
            case 0x88:
                SetCurrentInstructionName(() => "MOV rmb rb");
                _modRM.Read();
                _modRM.SetRm8(_modRM.GetR8());
                break;

            case 0x89:
                SetCurrentInstructionName(() => "MOV rmw rw");
                _modRM.Read();
                _modRM.SetRm16(_modRM.GetR16());
                break;

            case 0x8A:
                SetCurrentInstructionName(() => "MOV rb, rmb");
                _modRM.Read();
                _modRM.SetR8(_modRM.GetRm8());
                break;

            case 0x8B:
                SetCurrentInstructionName(() => "MOV rw rmw");
                _modRM.Read();
                _modRM.SetR16(_modRM.GetRm16());
                break;

            case 0x8C:
                SetCurrentInstructionName(() => "MOV rmw sreg");
                _modRM.Read();
                _modRM.SetRm16((ushort)_modRM.GetSegmentRegister());
                break;

            case 0x8D: {
                SetCurrentInstructionName(() => "LEA");
                _modRM.Read();
                ushort? memoryOffset = _modRM.GetMemoryOffset();
                if (memoryOffset == null) {
                    throw new InvalidVMOperationException(this._machine, "Memory address was not read by Mod R/M but it is needed for LEA");
                }
                _modRM.SetR16(memoryOffset.Value);
                break;
            }
            case 0x8E:
                SetCurrentInstructionName(() => "MOV sreg rmw");
                _modRM.Read();
                _modRM.SetSegmentRegister(_modRM.GetRm16());
                break;

            case 0x8F:
                SetCurrentInstructionName(() => "POP rmw");
                _modRM.Read();
                _modRM.SetRm16(_stack.Pop());
                break;

            case 0x90:
                SetCurrentInstructionName(() => "NOP");
                break;

            case 0x91:
            case 0x92:
            case 0x93:
            case 0x94:
            case 0x95:
            case 0x96:
            case 0x97: {
                regIndex = opcode & REG_INDEX_MASK;
                SetCurrentInstructionName(() => $"XCHG AX,{_state.GetRegisters().GetRegName(regIndex)}");
                ushort value1 = _state.GetAX();
                ushort value2 = _state.GetRegisters().GetRegister(regIndex);
                _state.SetAX(value2);
                _state.GetRegisters().SetRegister(regIndex, value1);
                break;
            }
            case 0x98:
                // Convert byte to word
                SetCurrentInstructionName(() => "CBW");
                _state.SetAX(_state.GetAL());
                break;

            case 0x99:
                // Sign extend AX into DX (word to dword)
                SetCurrentInstructionName(() => "CWD");
                if (_state.GetAX() >= 0x8000) {
                    _state.SetDX(0xFFFF);
                } else {
                    _state.SetDX(0);
                }
                break;

            case 0x9A: // FAR CALL
            {
                ushort ip = NextUint16();
                ushort cs = NextUint16();
                SetCurrentInstructionName(() => "FAR CALL");
                FarCall(_state.GetCS(), _internalIp, cs, ip);
                break;
            }
            // Do nothing, this is to wait for the FPU which is not implemented
            case 0x9B:
                SetCurrentInstructionName(() => "WAIT");
                break;

            case 0x9C:
                SetCurrentInstructionName(() => "PUSHF");
                _stack.Push(_state.GetFlags().GetFlagRegister());
                break;

            case 0x9D:
                SetCurrentInstructionName(() => "POPF");
                _state.GetFlags().SetFlagRegister(_stack.Pop());
                break;

            case 0x9E:
                SetCurrentInstructionName(() => "SAHF");
                _state.GetFlags().SetFlagRegister(_state.GetAH());
                break;

            case 0x9F:
                SetCurrentInstructionName(() => "LAHF");
                _state.SetAH((byte)_state.GetFlags().GetFlagRegister());
                break;

            case 0xA0:
                SetCurrentInstructionName(() => "MOV AL moffs8");
                _state.SetAL(_memory.GetUint8(GetDsNextUint16Address()));
                _staticAddressesRecorder.SetCurrentAddressOperation(ValueOperation.READ, OperandSize.Byte8);
                break;

            case 0xA1:
                SetCurrentInstructionName(() => "MOV AX moffs16");
                _state.SetAX(_memory.GetUint16(GetDsNextUint16Address()));
                _staticAddressesRecorder.SetCurrentAddressOperation(ValueOperation.READ, OperandSize.Word16);
                break;

            case 0xA2:
                SetCurrentInstructionName(() => "MOV moffs8 AL");
                _memory.SetUint8(GetDsNextUint16Address(), _state.GetAL());
                _staticAddressesRecorder.SetCurrentAddressOperation(ValueOperation.WRITE, OperandSize.Byte8);
                break;

            case 0xA3:
                SetCurrentInstructionName(() => "MOV moffs16 AX");
                _memory.SetUint16(GetDsNextUint16Address(), _state.GetAX());
                _staticAddressesRecorder.SetCurrentAddressOperation(ValueOperation.WRITE, OperandSize.Word16);
                break;

            case 0xA4:
            case 0xA5:
            case 0xA6:
            case 0xA7:
                ProcessString(opcode);
                break;

            case 0xA8:
                SetCurrentInstructionName(() => "TEST AL ib");
                _alu.And8(_state.GetAL(), NextUint8());
                break;

            case 0xA9:
                SetCurrentInstructionName(() => "TEST AX iw");
                _alu.And16(_state.GetAX(), NextUint16());
                break;

            case 0xAA:
            case 0xAB:
            case 0xAC:
            case 0xAD:
            case 0xAE:
            case 0xAF:
                ProcessString(opcode);
                break;

            case 0xB0:
            case 0xB1:
            case 0xB2:
            case 0xB3:
            case 0xB4:
            case 0xB5:
            case 0xB6:
            case 0xB7:
                regIndex = opcode & REG_INDEX_MASK;
                SetCurrentInstructionName(() => $"MOV {_state.GetRegisters().GetReg8Name(regIndex)} ib");
                _state.GetRegisters().SetRegisterFromHighLowIndex8(regIndex, NextUint8());
                break;

            case 0xB8:
            case 0xB9:
            case 0xBA:
            case 0xBB:
            case 0xBC:
            case 0xBD:
            case 0xBE:
            case 0xBF:
                regIndex = opcode & REG_INDEX_MASK;
                SetCurrentInstructionName(() => $"MOV {_state.GetRegisters().GetRegName(regIndex)} iw");
                _state.GetRegisters().SetRegister(regIndex, NextUint16());
                break;

            case 0xC0: {
                _modRM.Read();
                int count = this.NextUint8();
                byte value = _modRM.GetRm8();
                SetCurrentInstructionName(() => $"SHL rmb {count}");
                _modRM.SetRm8(_alu.Shl8(value, count));
                break;
            }
            case 0xC1: {
                _modRM.Read();
                int count = this.NextUint8();
                ushort value = _modRM.GetRm16();
                SetCurrentInstructionName(() => $"SHL rmw {count}");
                _modRM.SetRm16(_alu.Shl16(value, count));
                break;
            }
            case 0xC2: {
                int numberOfBytesToPop = NextUint8();
                SetCurrentInstructionName(() => $"RET and pop {numberOfBytesToPop} bytes");
                NearRet(numberOfBytesToPop);
                break;
            }
            case 0xC3:
                SetCurrentInstructionName(() => "RET");
                NearRet(0);
                break;

            case 0xC4:
            case 0xC5: {
                // Copy segmented address that is in memory (32bits) into DS/ES and the
                // specified register
                _modRM.Read();
                uint? memoryAddress = _modRM.GetMemoryAddress();
                if (memoryAddress == null) {
                    throw new InvalidVMOperationException(this._machine, "Memory address was not read by Mod R/M but it is needed for LES / LDS");
                }
                _modRM.SetR16(_memory.GetUint16(memoryAddress.Value));
                ushort value = _memory.GetUint16(memoryAddress.Value + 2);
                GetStaticAddressesRecorder().SetCurrentAddressOperation(ValueOperation.READ, OperandSize.Dword32);
                if (opcode == 0xC4) {
                    // LES
                    SetCurrentInstructionName(() => "LES rw md");
                    _state.SetES(value);
                } else {
                    // LDS
                    SetCurrentInstructionName(() => "LDS rw md");
                    _state.SetDS(value);
                }
                break;
            }
            case 0xC6:
                SetCurrentInstructionName(() => "MOV rmb ib");
                _modRM.Read();
                _modRM.SetRm8(NextUint8());
                break;

            case 0xC7:
                SetCurrentInstructionName(() => "MOV rmw iw");
                _modRM.Read();
                _modRM.SetRm16(NextUint16());
                break;

            case 0xC8:
            case 0xC9:
                HandleInvalidOpcode(opcode);
                break;

            case 0xCA: {
                byte numberOfBytesToPop = NextUint8();
                SetCurrentInstructionName(() => $"RETF and pop {numberOfBytesToPop} bytes");
                FarRet(numberOfBytesToPop);
                break;
            }
            case 0xCB:
                SetCurrentInstructionName(() => "RETF");
                FarRet(0);
                break;

            case 0xCC:
                SetCurrentInstructionName(() => "INT 3");
                Interrupt(3, false);
                break;

            case 0xCD:
                SetCurrentInstructionName(() => "INT ib");
                Interrupt(NextUint8(), false);
                break;

            case 0xCE:
                SetCurrentInstructionName(() => "INTO");
                if (_state.GetOverflowFlag()) {
                    Interrupt(4, false);
                }
                break;

            case 0xCF:
                SetCurrentInstructionName(() => "IRET");
                InterruptRet();
                break;

            case 0xD0:
            case 0xD1:
            case 0xD2:
            case 0xD3: // GRP2 rmb 1, GRP2 rmw 1, GRP2 rmb CL, GRP2 rmw CL
                Grp2(opcode);
                break;

            case 0xD4: {
                SetCurrentInstructionName(() => "AAM ib");
                byte v1 = _state.GetAL();
                byte v2 = NextUint8();
                if (v2 == 0) {
                    HandleDivisionError();
                    return;
                }
                byte result = (byte)(v1 % v2);
                _state.SetAH((byte)(v1 / v2));
                _state.SetAL(result);
                _alu.UpdateFlags8(result);
                break;
            }
            case 0xD5: {
                SetCurrentInstructionName(() => "AAD ib");
                byte result = (byte)(_state.GetAL() + (_state.GetAH() * NextUint8()));
                _state.SetAL(result);
                _state.SetAH(0);
                _state.GetFlags().SetFlagRegister(0);
                _alu.UpdateFlags8(result);
                break;
            }
            case 0xD6:
                HandleInvalidOpcode(opcode);
                break;

            case 0xD7: {
                SetCurrentInstructionName(() => "XLAT");
                uint address = _modRM.GetAddress(SegmentRegisters.DsIndex, _state.GetBX()) + _state.GetAL();
                _state.SetAL(_memory.GetUint8(address));
                break;
            }
            case 0xD8:
                HandleInvalidOpcode(opcode);
                break;

            case 0xD9: {
                _modRM.Read();
                int groupIndex = _modRM.GetRegisterIndex();
                if (groupIndex == 0x7) {
                    // Set the control word to the value expected after init since FPU is not supported.
                    _modRM.SetRm16(0x37F);
                    SetCurrentInstructionName(() => "FNSTCW");
                } else {
                    throw new InvalidGroupIndexException(_machine, groupIndex);
                }
                break;
            }
            case 0xDA:
                HandleInvalidOpcode(opcode);
                break;

            case 0xDB: {
                byte opCodeNextByte = NextUint8();
                if (opCodeNextByte != 0xE3) {
                    ushort fullOpCode = (ushort)((opcode << 8) | opCodeNextByte);
                    HandleInvalidOpcode(fullOpCode);
                }
                SetCurrentInstructionName(() => "FNINIT");
                // Do nothing, no FPU emulation, but this is used to detect FPU
                break;
            }
            case 0xDC:
                HandleInvalidOpcode(opcode);
                break;
            case 0xDD: {
                _modRM.Read();
                int groupIndex = _modRM.GetRegisterIndex();
                if (groupIndex == 0x7) {
                    // Set non zero, means no FPU installed when called after FNINIT.
                    _modRM.SetRm16(0xFF);
                    SetCurrentInstructionName(() => "FNSTSW");
                } else {
                    throw new InvalidGroupIndexException(_machine, groupIndex);
                }
                break;
            }
            case 0xDE:
            case 0xDF:
                HandleInvalidOpcode(opcode);
                break;

            case 0xE0:
            case 0xE1: { // LOOPZ / LOOPNZ
                bool zeroFlag = (opcode & 0x1) == 1;
                byte address = NextUint8();
                if (zeroFlag) {
                    SetCurrentInstructionName(() => $"LOOPZ {address}");
                } else {
                    SetCurrentInstructionName(() => $"LOOPNZ {address}");
                }
                ushort cx = (ushort)(_state.GetCX() - 1);
                _state.SetCX(cx);
                if (cx != 0 && _state.GetZeroFlag() == zeroFlag) {
                    _internalIp += address;
                }
                break;
            }
            case 0xE2: // LOOP
            {
                SetCurrentInstructionName(() => "LOOP");
                byte address = NextUint8();
                ushort cx = (ushort)(_state.GetCX() - 1);
                _state.SetCX(cx);
                if (cx != 0) {
                    _internalIp += address;
                }
                break;
            }
            case 0xE3: // JCXZ
                Jcc(opcode);
                break;

            case 0xE4: {
                byte port = NextUint8();
                SetCurrentInstructionName(() => $"IN AL {ConvertUtils.ToHex8(port)}");
                _state.SetAL(Inb(port));
                break;
            }
            case 0xE5: {
                ushort port = NextUint16();
                SetCurrentInstructionName(() => $"IN AL {ConvertUtils.ToHex16(port)}");
                _state.SetAX(Inw(port));
                break;
            }
            case 0xE6: {
                byte port = NextUint8();
                byte value = _state.GetAL();
                SetCurrentInstructionName(() => $"OUT {ConvertUtils.ToHex8(port)} AL={ConvertUtils.ToHex8(value)}");
                Outb(port, value);
                break;
            }
            case 0xE7: {
                ushort port = NextUint16();
                ushort value = _state.GetAX();
                SetCurrentInstructionName(() => $"OUT {ConvertUtils.ToHex16(port)} AX={ConvertUtils.ToHex16(value)}");
                Outw(port, value);
                break;
            }
            case 0xE8: {
                SetCurrentInstructionName(() => "CALL NEAR");
                ushort nextInstruction = (ushort)(_internalIp + 2);
                short offset = (short)NextUint16();
                ushort callAddress = (ushort)(nextInstruction + offset);
                NearCall(nextInstruction, callAddress);
                break;
            }
            case 0xE9: {
                short offset = (short)NextUint16();
                JumpNear((ushort)(_internalIp + offset));
                break;
            }
            case 0xEA: {
                ushort ip = NextUint16();
                ushort cs = NextUint16();
                JumpFar(cs, ip);
                break;
            }
            case 0xEB: {
                sbyte offset = (sbyte)NextUint8();
                JumpNear((ushort)(_internalIp + offset));
                break;
            }
            case 0xEC: {
                ushort port = _state.GetDX();
                SetCurrentInstructionName(() => "IN AL DX=" + ConvertUtils.ToHex16(port));
                _state.SetAL(Inb(port));
                break;
            }
            case 0xED: {
                ushort port = _state.GetDX();
                SetCurrentInstructionName(() => "IN AX DX=" + ConvertUtils.ToHex16(port));
                _state.SetAX(Inw(port));
                break;
            }
            case 0xEE: {
                ushort port = _state.GetDX();
                byte value = _state.GetAL();
                SetCurrentInstructionName(() => "OUT DX=" + ConvertUtils.ToHex16(port) + " AL=" + ConvertUtils.ToHex8(value));
                Outb(port, value);
                break;
            }
            case 0xEF: {
                ushort port = _state.GetDX();
                ushort value = _state.GetAX();
                SetCurrentInstructionName(() => "OUT DX=" + ConvertUtils.ToHex16(port) + " AX=" + ConvertUtils.ToHex16(value));
                Outw(port, value);
                break;
            }
            case 0xF0:
            case 0xF1:
                HandleInvalidOpcode(opcode);
                break;

            case 0xF2:
            case 0xF3:
                HandleInvalidOpcodeBecausePrefix(opcode);
                break;

            case 0xF4:
                SetCurrentInstructionName(() => "HLT");
                _logger.Information("HLT instruction encountered, halting!");
                _running = false;
                break;

            case 0xF5:
                SetCurrentInstructionName(() => "CMC");
                _state.SetCarryFlag(!_state.GetCarryFlag());
                break;

            case 0xF6: // GRP3a rmb
                Grp3a();
                break;

            case 0xF7: // GRP3b rmw
                Grp3b();
                break;

            case 0xF8:
                SetCurrentInstructionName(() => "CLC");
                _state.SetCarryFlag(false);
                break;

            case 0xF9:
                SetCurrentInstructionName(() => "STC");
                _state.SetCarryFlag(true);
                break;

            case 0xFA:
                SetCurrentInstructionName(() => "CLI");
                _state.SetInterruptFlag(false);
                break;

            case 0xFB:
                SetCurrentInstructionName(() => "STI");
                _state.SetInterruptFlag(true);
                break;

            case 0xFC:
                SetCurrentInstructionName(() => "CLD");
                _state.SetDirectionFlag(false);
                break;

            case 0xFD:
                SetCurrentInstructionName(() => "STD");
                _state.SetDirectionFlag(true);
                break;

            case 0xFE: // GRP4 rmb
                Grp4();
                break;

            case 0xFF: // GRP5 rmw
                Grp5();
                break;
        }
    }

    private void FarCall(ushort returnCS, ushort returnIP, ushort targetCS, ushort targetIP) {
        _stack.Push(returnCS);
        _stack.Push(returnIP);
        _state.SetCS(targetCS);
        _internalIp = targetIP;
        HandleCall(CallType.FAR, returnCS, returnIP, targetCS, targetIP);
    }

    private string Generate8Or16Value(bool op1Byte, ushort op1, ushort op2) {
        if (op1Byte) {
            return $"8 ({ConvertUtils.ToHex8((byte)op1)},{ConvertUtils.ToHex8((byte)op2)})";
        }
        return $"16 ({ConvertUtils.ToHex16(op1)},{ConvertUtils.ToHex16(op2)})";
    }

    private string GenerateGrp1Name(int groupIndex, bool op1Byte, ushort op1, ushort op2) {
        string opName = (groupIndex) switch {
            0 => "ADD",
            1 => "OR",
            2 => "ADC",
            3 => "SBB",
            4 => "AND",
            5 => "SUB",
            6 => "XOR",
            7 => "CMP",
            _ => "",
        };
        return opName + Generate8Or16Value(op1Byte, op1, op2);
    }

    private string GenerateGrp2Name(int groupIndex, bool op1Byte, ushort op1, ushort op2) {
        var opName = (groupIndex) switch {
            0 => "ROL",
            1 => "ROR",
            2 => "RCL",
            3 => "RCR",
            4 => "SHL",
            5 => "SHR",
            7 => "SAR",
            _ => ""
        };
        return opName + Generate8Or16Value(op1Byte, op1, op2);
    }

    private uint GetDsNextUint16Address() {
        return _modRM.GetAddress(SegmentRegisters.DsIndex, NextUint16(), true);
    }

    private uint GetInternalIpPhysicalAddress() => MemoryUtils.ToPhysicalAddress(_state.GetCS(), _internalIp);

    private uint GetMemoryAddressEsDi() => MemoryUtils.ToPhysicalAddress(_state.GetES(), _state.GetDI());

    private uint GetMemoryAddressOverridableDsSi() => _modRM.GetAddress(SegmentRegisters.DsIndex, _state.GetSI());

    private ushort GetRm8Or16(bool op1Byte) {
        if (op1Byte) {
            return _modRM.GetRm8();
        }
        return _modRM.GetRm16();
    }

    private void Grp1(int opcode) {
        _modRM.Read();
        int groupIndex = _modRM.GetRegisterIndex();
        bool op1Byte = (opcode & 0b01) == 0;
        bool op2Byte = (opcode & 0b11) != 1;
        ushort op2;
        if (op2Byte) {
            if (op1Byte) {
                op2 = NextUint8();
            } else {
                // preserve sign in byte so that it can be extended later if needed
                op2 = (ushort)(sbyte)NextUint8();
            }
        } else {
            op2 = NextUint16();
        }
        ushort op1 = GetRm8Or16(op1Byte);
        SetCurrentInstructionName(() => GenerateGrp1Name(groupIndex, op1Byte, op1, op2));
        ushort res;
        if (op1Byte) {
            res = (groupIndex) switch {
                0 => _alu.Add8((byte)op1, (byte)op2),
                1 => _alu.Or8((byte)op1, (byte)op2),
                2 => _alu.Adc8((byte)op1, (byte)op2),
                3 => _alu.Sbb8((byte)op1, (byte)op2),
                4 => _alu.And8((byte)op1, (byte)op2),
                5 => _alu.Sub8((byte)op1, (byte)op2),
                6 => _alu.Xor8((byte)op1, (byte)op2),
                7 => _alu.Sub8((byte)op1, (byte)op2),
                _ => throw new InvalidGroupIndexException(_machine, groupIndex)
            };
        } else {
            res = (groupIndex) switch {
                0 => _alu.Add16(op1, op2),
                1 => _alu.Or16(op1, op2),
                2 => _alu.Adc16(op1, op2),
                3 => _alu.Sbb16(op1, op2),
                4 => _alu.And16(op1, op2),
                5 => _alu.Sub16(op1, op2),
                6 => _alu.Xor16(op1, op2),
                7 => _alu.Sub16(op1, op2),
                _ => throw new InvalidGroupIndexException(_machine, groupIndex)
            };
        }
        // 7 is CMP so no memory to set
        if (groupIndex != 7) {
            if (op1Byte) {
                _modRM.SetRm8((byte)res);
            } else {
                _modRM.SetRm16(res);
            }
        }
    }

    private void Grp2(int opcode) {
        // GRP2 rmb 1
        _modRM.Read();
        int groupIndex = _modRM.GetRegisterIndex();
        bool op1Byte = (opcode & 0b01) == 0;

        bool valueIsCL = (opcode & 0b10) == 0b10; // if it 0b10, it is CL
        ushort op2;
        if (valueIsCL) {
            op2 = _state.GetCL();
        } else {
            op2 = 1;
        }
        ushort op1 = GetRm8Or16(op1Byte);
        SetCurrentInstructionName(() => GenerateGrp2Name(groupIndex, op1Byte, op1, op2));
        ushort res;
        if (op1Byte) {
            res = (groupIndex) switch {
                0 => _alu.Rol8((byte)op1, (byte)op2),
                1 => _alu.Ror8((byte)op1, (byte)op2),
                2 => _alu.Rcl8((byte)op1, (byte)op2),
                3 => _alu.Rcr8((byte)op1, (byte)op2),
                4 => _alu.Shl8((byte)op1, (byte)op2),
                5 => _alu.Shr8((byte)op1, (byte)op2),
                7 => _alu.Sar8((byte)op1, (byte)op2),
                _ => throw new InvalidGroupIndexException(_machine, groupIndex)
            };
        } else {
            res = (groupIndex) switch {
                0 => _alu.Rol16(op1, op2),
                1 => _alu.Ror16(op1, op2),
                2 => _alu.Rcl16(op1, op2),
                3 => _alu.Rcr16(op1, op2),
                4 => _alu.Shl16(op1, op2),
                5 => _alu.Shr16(op1, op2),
                7 => _alu.Sar16(op1, op2),
                _ => throw new InvalidGroupIndexException(_machine, groupIndex)
            };
        }
        if (op1Byte) {
            _modRM.SetRm8((byte)res);
        } else {
            _modRM.SetRm16(res);
        }
    }

    private void Grp3a() {
        _modRM.Read();
        int groupIndex = _modRM.GetRegisterIndex();
        switch (groupIndex) {
            case 0: {
                SetCurrentInstructionName(() => "TEST8");
                _alu.And8(_modRM.GetRm8(), NextUint8());
                break;
            }
            case 2: {
                SetCurrentInstructionName(() => "NOT8");
                _modRM.SetRm8((byte)~_modRM.GetRm8());
                break;
            }
            case 3: {
                SetCurrentInstructionName(() => "NEG8");
                byte value = _modRM.GetRm8();
                value = _alu.Sub8(0, value);
                _modRM.SetRm8(value);
                _state.SetCarryFlag(value != 0);
                break;
            }
            case 4: {
                SetCurrentInstructionName(() => "MUL8");
                ushort result = _alu.Mul8(_state.GetAL(), _modRM.GetRm8());
                // Upper part of the result goes in AH
                _state.SetAH((byte)(result >> 8));
                _state.SetAL((byte)result);
                break;
            }
            case 5: {
                SetCurrentInstructionName(() => "IMUL8");
                short result = _alu.Imul8((sbyte)_state.GetAL(), (sbyte)_modRM.GetRm8());
                // Upper part of the result goes in AH
                _state.SetAH((byte)(result >> 8));
                _state.SetAL((byte)result);
                break;
            }
            case 6: {
                SetCurrentInstructionName(() => "DIV8");
                ushort v1 = _state.GetAX();
                byte v2 = _modRM.GetRm8();
                byte? result = _alu.Div8(v1, v2);
                if (result == null) {
                    HandleDivisionError();
                    return;
                }
                _state.SetAL(result.Value);
                _state.SetAH((byte)(v1 % v2));
                break;
            }
            case 7: {
                SetCurrentInstructionName(() => "IDIV8");
                short v1 = (short)_state.GetAX();
                sbyte v2 = (sbyte)_modRM.GetRm8();
                sbyte? result = _alu.Idiv8(v1, v2);
                if (result == null) {
                    HandleDivisionError();
                    return;
                }
                _state.SetAL((byte)result.Value);
                _state.SetAH((byte)(v1 % v2));
                break;
            }
            default:
                throw new InvalidGroupIndexException(_machine, groupIndex);
        }
    }

    private void Grp3b() {
        _modRM.Read();
        int groupIndex = _modRM.GetRegisterIndex();
        switch (groupIndex) {
            case 0:
                SetCurrentInstructionName(() => "TEST16");
                _alu.And16(_modRM.GetRm16(), NextUint16());
                break;
            case 2:
                SetCurrentInstructionName(() => "NOT16");
                _modRM.SetRm16((ushort)~_modRM.GetRm16());
                break;
            case 3: {
                SetCurrentInstructionName(() => "NEG16");
                ushort value = _modRM.GetRm16();
                value = _alu.Sub16(0, value);
                _modRM.SetRm16(value);
                _state.SetCarryFlag(value != 0);
                break;
            }
            case 4: {
                SetCurrentInstructionName(() => "MUL16");
                uint result = _alu.Mul16(_state.GetAX(), _modRM.GetRm16());
                // Upper part of the result goes in DX
                _state.SetDX((ushort)(result >> 16));
                _state.SetAX((ushort)result);
                break;
            }
            case 5: {
                SetCurrentInstructionName(() => "IMUL16");
                int result = _alu.Imul16((short)_state.GetAX(), (short)_modRM.GetRm16());
                // Upper part of the result goes in DX
                _state.SetDX((ushort)(result >> 16));
                _state.SetAX((ushort)result);
                break;
            }
            case 6: {
                SetCurrentInstructionName(() => "DIV16");
                uint v1 = (uint)((_state.GetDX() << 16) | _state.GetAX());
                ushort v2 = _modRM.GetRm16();
                ushort? result = _alu.Div16(v1, v2);
                if (result == null) {
                    HandleDivisionError();
                    return;
                }
                _state.SetAX(result.Value);
                _state.SetDX((ushort)(v1 % v2));
                break;
            }
            case 7: {
                SetCurrentInstructionName(() => "IDIV16");
                // no sign extension for v1 as it is already a 32bit value
                int v1 = (_state.GetDX() << 16) | _state.GetAX();
                short v2 = (short)_modRM.GetRm16();
                short? result = _alu.Idiv16(v1, v2);
                if (result == null) {
                    HandleDivisionError();
                    return;
                }
                _state.SetAX((ushort)result.Value);
                _state.SetDX((ushort)(v1 % v2));
                break;
            }
            default:
                throw new InvalidGroupIndexException(_machine, groupIndex);
        }
    }

    private void Grp4() {
        _modRM.Read();
        int groupIndex = _modRM.GetRegisterIndex();
        switch (groupIndex) {
            case 0:
                SetCurrentInstructionName(() => "INC");
                _modRM.SetRm8(_alu.Inc8(_modRM.GetRm8()));
                break;
            case 1:
                SetCurrentInstructionName(() => "DEC");
                _modRM.SetRm8(_alu.Dec8(_modRM.GetRm8()));
                break;
            case 7:
                // Callback, emulator specific instruction FE38 like in dosbox,
                // to allow interrupts to be overridden by the program
                Callback(NextUint8());
                break;
            default:
                throw new InvalidGroupIndexException(_machine, groupIndex);
        }
    }

    private void Grp5() {
        _modRM.Read();
        int groupIndex = _modRM.GetRegisterIndex();
        switch (groupIndex) {
            case 0:
                SetCurrentInstructionName(() => "INC");
                _modRM.SetRm16(_alu.Inc16(_modRM.GetRm16()));
                break;
            case 1:
                SetCurrentInstructionName(() => "DEC");
                _modRM.SetRm16(_alu.Dec16(_modRM.GetRm16()));
                break;
            case 2:
                SetCurrentInstructionName(() => "NEAR CALL");
                ushort callAddress = _modRM.GetRm16();
                NearCall(_internalIp, callAddress);
                break;
            case 3: {
                SetCurrentInstructionName(() => "FAR CALL");
                uint? ipAddress = _modRM.GetMemoryAddress();
                if (ipAddress is null) {
                    return;
                }
                GetStaticAddressesRecorder().SetCurrentAddressOperation(ValueOperation.READ, OperandSize.Dword32Ptr);
                ushort ip = _memory.GetUint16(ipAddress.Value);
                ushort cs = _memory.GetUint16(ipAddress.Value + 2);
                FarCall(_state.GetCS(), _internalIp, cs, ip);
                break;
            }
            case 4: {
                ushort ip = _modRM.GetRm16();
                JumpNear(ip);
                break;
            }
            case 5: {
                uint? ipAddress = _modRM.GetMemoryAddress();
                if (ipAddress is null) {
                    return;
                }
                GetStaticAddressesRecorder().SetCurrentAddressOperation(ValueOperation.READ, OperandSize.Dword32Ptr);
                ushort ip = _memory.GetUint16(ipAddress.Value);
                ushort cs = _memory.GetUint16(ipAddress.Value + 2);
                JumpFar(cs, ip);
                break;
            }
            case 6:
                SetCurrentInstructionName(() => "PUSH");
                _stack.Push(_modRM.GetRm16());
                break;
            default:
                throw new InvalidGroupIndexException(_machine, groupIndex);
        }
    }

    private void HandleCall(CallType callType, ushort returnCS, ushort returnIP, ushort targetCS, ushort targetIP) {
        if (IsLoggingEnabled()) {
            _logger.Debug("CALL {@TargetCsTargetIp}, will return to {@ReturnCsReturnIp}", ConvertUtils.ToSegmentedAddressRepresentation(targetCS, targetIP),
                ConvertUtils.ToSegmentedAddressRepresentation(returnCS, returnIP));
        }
        _functionHandlerInUse.Call(callType, targetCS, targetIP, returnCS, returnIP);
    }

    private void HandleDivisionError() {
        // Reset IP because instruction is not finished (this is how an actual CPU behaves)
        _internalIp = _state.GetIP();
        Interrupt(0, false);
    }

    private void HandleExternalInterrupt() {
        if (_externalInterruptVectorNumber == null || !_state.GetInterruptFlag()) {
            return;
        }
        if (IsLoggingEnabled()) {
            _logger.Debug("Interrupted!, {@ExternalInterruptVectorNumber}", _externalInterruptVectorNumber);
        }
        Interrupt(_externalInterruptVectorNumber, true);
        _externalInterruptVectorNumber = null;
    }

    private void HandleInvalidOpcode(ushort opcode) => throw new InvalidOpCodeException(_machine, opcode, false);

    private void HandleInvalidOpcodeBecausePrefix(byte opcode) => throw new InvalidOpCodeException(_machine, opcode, true);

    private void HandleJump(ushort cs, ushort ip) {
        _internalIp = ip;
        _state.SetCS(cs);
    }

    private byte Inb(int port) {
        if (_ioPortDispatcher != null) {
            return _ioPortDispatcher.Inb((ushort)port);
        }
        return 0;
    }

    private void Interrupt(byte? vectorNumber, bool external) {
        if (vectorNumber == null) {
            return;
        }
        ushort targetIP = _memory.GetUint16((ushort)(4 * vectorNumber.Value));
        ushort targetCS = _memory.GetUint16((ushort)(4 * vectorNumber.Value + 2));
        if (_errorOnUninitializedInterruptHandler && targetCS == 0 && targetIP == 0) {
            throw new UnhandledOperationException(_machine,
                $"Int was called but vector was not initialized for vectorNumber={ConvertUtils.ToHex(vectorNumber.Value)}");
        }
        ushort returnCS = _state.GetCS();
        ushort returnIP = _internalIp;
        if (IsLoggingEnabled()) {
            _logger.Debug("int {@VectorNumber} handler found in memory, {@SegmentedAddressRepresentation}", ConvertUtils.ToHex(vectorNumber.Value),
                ConvertUtils.ToSegmentedAddressRepresentation(targetCS, targetIP));
        }
        _stack.Push(_state.GetFlags().GetFlagRegister());
        _stack.Push(returnCS);
        _stack.Push(returnIP);
        _state.SetInterruptFlag(false);
        _internalIp = targetIP;
        _state.SetCS(targetCS);
        var recordReturn = true;
        if (external) {
            _functionHandlerInUse = _functionHandlerInExternalInterrupt;
            recordReturn = false;
        }
        _functionHandlerInUse.Icall(CallType.INTERRUPT, targetCS, targetIP, returnCS, returnIP, vectorNumber.Value,
            recordReturn);
    }

    private ushort Inw(int port) {
        if (_ioPortDispatcher != null) {
            return _ioPortDispatcher.Inw((ushort)port);
        }
        return 0;
    }

    private bool IsLoggingEnabled() {
        if (_forceLog == null) {
            return _logger.IsEnabled(Serilog.Events.LogEventLevel.Debug);
        }
        return _forceLog.Value;
    }

    private bool IsPrefix(int opcode) => PREFIXES_OPCODES.Contains(opcode);

    private bool IsStringOpcode(int opcode) {
        return STRING_OPCODES.Contains(opcode);
    }

    /// <summary>
    /// Jumps handling
    /// </summary>
    private void Jcc(ushort opcode) {
        byte address = NextUint8();
        bool jump = opcode switch {
            0x70 => _state.GetOverflowFlag(),
            0x71 => !_state.GetOverflowFlag(),
            0x72 => _state.GetCarryFlag(),
            0x73 => !_state.GetCarryFlag(),
            0x74 => _state.GetZeroFlag(),
            0x75 => !_state.GetZeroFlag(),
            0x76 => _state.GetCarryFlag() || _state.GetZeroFlag(),
            0x77 => !_state.GetCarryFlag() && !_state.GetZeroFlag(),
            0x78 => _state.GetSignFlag(),
            0x79 => !_state.GetSignFlag(),
            0x7A => _state.GetParityFlag(),
            0x7B => !_state.GetParityFlag(),
            0x7C => _state.GetSignFlag() != _state.GetOverflowFlag(),
            0x7D => _state.GetSignFlag() == _state.GetOverflowFlag(),
            0x7E => _state.GetZeroFlag() || _state.GetSignFlag() != _state.GetOverflowFlag(),
            0x7F => !_state.GetZeroFlag() && _state.GetSignFlag() == _state.GetOverflowFlag(),
            0xE3 => _state.GetCX() == 0,
            _ => throw new InvalidOpCodeException(_machine, opcode, false)
        };
        SetCurrentInstructionName(() => opcode switch {
            0x70 => "JO",
            0x71 => "JNO",
            0x72 => "JB",
            0x73 => "JNB",
            0x74 => "JZ",
            0x75 => "JNZ",
            0x76 => "JBE",
            0x77 => "JA",
            0x78 => "JS",
            0x79 => "JNS",
            0x7A => "JP",
            0x7B => "JPO",
            0x7C => "JL",
            0x7D => "JGE",
            0x7E => "JNG",
            0x7F => "JG",
            0xE3 => "JCXZ",
            _ => ""
        } + " " + address + " jump?" + jump);
        if (jump) {
            _internalIp += address;
        }
    }

    private void JumpFar(ushort cs, ushort ip) {
        SetCurrentInstructionName(
            () => $"JMP FAR {ConvertUtils.ToSegmentedAddressRepresentation(cs, ip)}");
        HandleJump(cs, ip);
    }

    private void JumpNear(ushort ip) {
        SetCurrentInstructionName(
            () => $"JMP NEAR {ConvertUtils.ToSegmentedAddressRepresentation(_state.GetCS(), ip)}");
        HandleJump(_state.GetCS(), ip);
    }

    private void NearCall(ushort returnIP, ushort callIP) {
        _stack.Push(returnIP);
        _internalIp = callIP;
        HandleCall(CallType.NEAR, _state.GetCS(), returnIP, _state.GetCS(), callIP);
    }

    private void Outb(int port, byte val) {
        if (_ioPortDispatcher != null) {
            _ioPortDispatcher.Outb((ushort)port, val);
        }
    }

    private void Outw(int port, ushort val) {
        if (_ioPortDispatcher != null) {
            _ioPortDispatcher.Outw((ushort)port, val);
        }
    }

    private void ProcessPrefix(int opcode) {
        switch (opcode) {
            case 0x26:
                AddCurrentInstructionPrefix(() => "ES:");
                _state.SetSegmentOverrideIndex(SegmentRegisters.EsIndex);
                break;

            case 0x2E:
                AddCurrentInstructionPrefix(() => "CS:");
                _state.SetSegmentOverrideIndex(SegmentRegisters.CsIndex);
                break;

            case 0x36:
                AddCurrentInstructionPrefix(() => "SS:");
                _state.SetSegmentOverrideIndex(SegmentRegisters.SsIndex);
                break;

            case 0x3E:
                AddCurrentInstructionPrefix(() => "DS:");
                _state.SetSegmentOverrideIndex(SegmentRegisters.DsIndex);
                break;

            case 0x64:
                AddCurrentInstructionPrefix(() => "FS:");
                _state.SetSegmentOverrideIndex(SegmentRegisters.FsIndex);
                break;

            case 0x65:
                AddCurrentInstructionPrefix(() => "GS:");
                _state.SetSegmentOverrideIndex(SegmentRegisters.GsIndex);
                break;

            case 0xF0:
                AddCurrentInstructionPrefix(() => "LOCK");
                break;

            case 0xF2:
            case 0xF3: // REPNZ, REPZ
            {
                bool continueZeroFlagValue = (opcode & 1) == 1;
                _state.SetContinueZeroFlagValue(continueZeroFlagValue);
                AddCurrentInstructionPrefix(() => "REP" + (continueZeroFlagValue ? "Z" : ""));
                break;
            }
            default:
                throw new InvalidVMOperationException(_machine,
                    $"processPrefix Called with a non prefix opcode {opcode}");
        }
    }

    private byte ProcessPrefixes() {
        byte opcode = NextUint8();
        while (IsPrefix(opcode)) {
            ProcessPrefix(opcode);
            opcode = NextUint8();
        }
        return opcode;
    }

    private void ProcessRep(byte opcode) {
        // repeat while zero flag is false for REPNZ (last bit is 0)
        // or while zero flag is true for REPZ (last bit is 1)
        bool? continueZeroFlagValue = _state.GetContinueZeroFlagValue();
        // For some instructions, zero flag is not to be checked
        bool checkZeroFlag = IsStringOpUpdatingFlags(opcode);
        ushort cx = _state.GetCX();
        while (cx != 0) {
            // re-set the segment override that may have been cleared. No need to reset ip
            // as string instructions don't modify it and are only one byte.
            ProcessString(opcode);
            cx--;

            if (_logger.IsEnabled(Serilog.Events.LogEventLevel.Verbose)) {
                _logger.Verbose("{@Rep} Loop, {@Cx}, {@If}, {@CheckZeroFlag}, {@ContinueZF}",
                    _state.GetCurrentInstructionNameWithPrefix(),
                    ConvertUtils.ToHex(cx), _state.GetZeroFlag(), checkZeroFlag, continueZeroFlagValue);
            }
            // Not all the string operations require checking the zero flag...
            if (checkZeroFlag && _state.GetZeroFlag() != continueZeroFlagValue) {
                break;
            }
        }
        _state.SetCX(cx);
    }

    private void ProcessString(ushort opcode) {
        int diff = (_state.GetDirectionFlag() ? -1 : 1) << (opcode & 1);
        switch (opcode) {
            case 0xA4: {
                SetCurrentInstructionName(() => "MOVSB");
                byte value = _memory.GetUint8(GetMemoryAddressOverridableDsSi());
                _memory.SetUint8(GetMemoryAddressEsDi(), value);
                _state.SetSI((ushort)(_state.GetSI() + diff));
                _state.SetDI((ushort)(_state.GetDI() + diff));
                break;
            }
            case 0xA5: {
                SetCurrentInstructionName(() => "MOVSW");
                ushort value = _memory.GetUint16(GetMemoryAddressOverridableDsSi());
                _memory.SetUint16(GetMemoryAddressEsDi(), value);
                _state.SetSI((ushort)(_state.GetSI() + diff));
                _state.SetDI((ushort)(_state.GetDI() + diff));
                break;
            }
            case 0xA6: {
                SetCurrentInstructionName(() => "CMPSB");
                byte value = _memory.GetUint8(GetMemoryAddressOverridableDsSi());
                _alu.Sub8(value, _memory.GetUint8(GetMemoryAddressEsDi()));
                _state.SetSI((ushort)(_state.GetSI() + diff));
                _state.SetDI((ushort)(_state.GetDI() + diff));
                break;
            }
            case 0xA7: {
                SetCurrentInstructionName(() => "CMPSW");
                ushort value = _memory.GetUint16(GetMemoryAddressOverridableDsSi());
                _alu.Sub16(value, _memory.GetUint16(GetMemoryAddressEsDi()));
                _state.SetSI((ushort)(_state.GetSI() + diff));
                _state.SetDI((ushort)(_state.GetDI() + diff));
                break;
            }
            case 0xAA:
                SetCurrentInstructionName(() => "STOSB");
                _memory.SetUint8(GetMemoryAddressEsDi(), _state.GetAL());
                _state.SetDI((ushort)(_state.GetDI() + diff));
                break;

            case 0xAB:
                SetCurrentInstructionName(() => "STOSW");
                _memory.SetUint16(GetMemoryAddressEsDi(), _state.GetAX());
                _state.SetDI((ushort)(_state.GetDI() + diff));
                break;

            case 0xAC: {
                SetCurrentInstructionName(() => "LODSB");
                byte value = _memory.GetUint8(GetMemoryAddressOverridableDsSi());
                _state.SetAL(value);
                _state.SetSI((ushort)(_state.GetSI() + diff));
                break;
            }
            case 0xAD: {
                SetCurrentInstructionName(() => "LODSW");
                ushort value = _memory.GetUint16(GetMemoryAddressOverridableDsSi());
                _state.SetAX(value);
                _state.SetSI((ushort)(_state.GetSI() + diff));
                break;
            }
            case 0xAE:
                SetCurrentInstructionName(() => "SCASB");
                _alu.Sub8(_state.GetAL(), _memory.GetUint8(GetMemoryAddressEsDi()));
                _state.SetDI((ushort)(_state.GetDI() + diff));
                break;

            case 0xAF:
                SetCurrentInstructionName(() => "SCASW");
                _alu.Sub16(_state.GetAX(), _memory.GetUint16(GetMemoryAddressEsDi()));
                _state.SetDI((ushort)(_state.GetDI() + diff));
                break;

            case 0x6C: {
                SetCurrentInstructionName(() => "INSB");
                ushort port = _state.GetDX();
                byte value = Inb(port);
                _memory.SetUint8(GetMemoryAddressEsDi(), value);
                _state.SetSI((ushort)(_state.GetSI() + diff));
                break;
            }
            case 0x6D: {
                SetCurrentInstructionName(() => "INSW");
                ushort port = _state.GetDX();
                ushort value = Inw(port);
                _memory.SetUint16(GetMemoryAddressEsDi(), value);
                _state.SetSI((ushort)(_state.GetSI() + diff));
                break;
            }
            case 0x6E: {
                SetCurrentInstructionName(() => "OUTSB");
                ushort port = _state.GetDX();
                byte value = _memory.GetUint8(GetMemoryAddressOverridableDsSi());
                Outb(port, value);
                _state.SetSI((ushort)(_state.GetSI() + diff));
                break;
            }
            case 0x6F: {
                SetCurrentInstructionName(() => "OUTSW");
                ushort port = _state.GetDX();
                ushort value = _memory.GetUint16(GetMemoryAddressOverridableDsSi());
                Outw(port, value);
                _state.SetSI((ushort)(_state.GetSI() + diff));
                break;
            }
            default:
                HandleInvalidOpcode(opcode);
                break;
        }
    }

    private void SetCurrentInstructionName(Func<String> getLog) {
        // Optimization, do not calculate the log if it is not used
        if (IsLoggingEnabled()) {
            _state.SetCurrentInstructionName(getLog.Invoke());
        }
    }

    // SCASW
}