namespace Spice86.Emulator.Cpu;

using Serilog;

using Spice86.Emulator.Callback;
using Spice86.Emulator.Errors;
using Spice86.Emulator.Function;
using Spice86.Emulator.IOPorts;
using Spice86.Emulator.Machine;
using Spice86.Emulator.Memory;
using Spice86.Utils;

using System;
using System.Collections.Generic;
using System.Linq;

/// <summary>
/// Implementation of a 8086 CPU. <br /> It has some 80186, 80286 and 80386 instructions as some
/// program use them. <br /> It also has some x87 FPU instructions to support telling the programs
/// that x87 is not supported :) <br /> Some docs that helped the implementation: <ul> <li>
/// Instructions decoding: http://rubbermallet.org/8086%20notes.pdf and
/// http://ref.x86asm.net/coder32.html </li><li> Instructions implementation details:
/// https://www.felixcloutier.com/x86/ </li><li> Pure 8086 instructions:
/// https://jbwyatt.com/253/emu/8086_instruction_set.html </li></ul>
/// TODO: Complete it !
/// </summary>
public class Cpu
{

    private static readonly ILogger _logger = Log.Logger.ForContext<Cpu>();

    // Extract regIndex from opcode
    private const int REG_INDEX_MASK = 0b111;
    private static readonly List<int> PREFIXES_OPCODES = new int[] { 0x26, 0x2E, 0x36, 0x3E, 0x64, 0x65, 0xF0, 0xF2, 0xF3 }.ToList();
    private static readonly List<int> STRING_OPCODES = new int[] { 0xA4, 0xA5, 0xA6, 0xA7, 0xAA, 0xAB, 0xAC, 0xAD, 0xAE, 0xAF, 0x6C, 0x6D, 0x6E, 0x6F }.ToList();

    private Machine _machine;
    private State _state;
    private Memory _memory;
    private ModRM _modRM;
    private Alu _alu;
    private Stack _stack;
    private CallbackHandler _callbackHandler;
    private IOPortDispatcher _ioPortDispatcher;
    private FunctionHandler _functionHandler;
    private FunctionHandler _functionHandlerInExternalInterrupt;
    private FunctionHandler _functionHandlerInUse;
    private StaticAddressesRecorder _staticAddressesRecorder;
    // Value used to read parts of the instruction.
    // CPU uses this internally and adjusts IP after instruction execution is done.
    private int _internalIp;
    private bool _running = true;
    // interrupt not generated by the code
    private int? _externalInterruptVectorNumber;
    // When true will crash if an interrupt targets code at 0000:0000
    private bool _errorOnUninitializedInterruptHandler;
    private bool? _forceLog;

    public Cpu(Machine machine, bool debugMode)
    {
        _machine = machine;
        _memory = machine.GetMemory();
        _state = new State();
        _alu = new Alu(_state);
        _stack = new Stack(_memory, _state);
        _functionHandler = new FunctionHandler(machine, debugMode);
        _functionHandlerInExternalInterrupt = new FunctionHandler(machine, debugMode);
        _functionHandlerInUse = _functionHandler;
        _staticAddressesRecorder = new StaticAddressesRecorder(_state, debugMode);
        _modRM = new ModRM(machine, this);
    }

    public State GetState() => _state;

    public Alu GetAlu() => _alu;
    public Stack GetStack() => _stack;

    public bool IsRunning => _running;

    public void SetRunning(bool running) => _running = running;

    public void SetCallbackHandler(CallbackHandler callbackHandler) => _callbackHandler = callbackHandler;

    public void SetIoPortDispatcher(IOPortDispatcher iOPortDispatcher) => _ioPortDispatcher = iOPortDispatcher;

    public FunctionHandler GetFunctionHandler() => _functionHandler;

    public FunctionHandler GetFunctionHandlerInExternalInterrupt() => _functionHandlerInExternalInterrupt;

    public FunctionHandler GetFunctionHandlerInUse() => _functionHandlerInUse;

    public StaticAddressesRecorder GetStaticAddresRecorder => _staticAddressesRecorder;

    public void SetForceLog(bool forceLog) => _forceLog = forceLog;

    internal void ExternalInterrupt(int vectorNumber)
    {
        // hack: do not let the timer overwrite keyboard.
        if (_externalInterruptVectorNumber == null || _externalInterruptVectorNumber != 9)
        {
            _externalInterruptVectorNumber = vectorNumber;
        }
    }

    public void SetErrorOnUninitializedInterruptHandler(bool errorOnUninitializedInterruptHandler)
    {
        _errorOnUninitializedInterruptHandler = errorOnUninitializedInterruptHandler;
    }

    private void AddCurrentInstructionPrefix(Func<String> getLog)
    {
        // Optimization, do not calculate the log if it is not used
        if (IsLoggingEnabled())
        {
            _state.AddCurrentInstructionPrefix(getLog.Invoke());
        }
    }

    private void SetCurrentInstructionName(Func<String> getLog)
    {
        // Optimization, do not calculate the log if it is not used
        if (IsLoggingEnabled())
        {
            _state.SetCurrentInstructionName(getLog.Invoke());
        }
    }

    private bool IsLoggingEnabled()
    {
        if (_forceLog == null)
        {
            return _logger.IsEnabled(Serilog.Events.LogEventLevel.Debug);
        }
        return _forceLog.Value;
    }

    public void ExecuteNextInstruction()
    {
        _internalIp = _state.GetIP();
        _staticAddressesRecorder.Reset();
        var stateString = "";
        if(IsLoggingEnabled())
        {
            stateString = _state.ToString();
            _state.ResetCurrentInstructionPrefix();
            _state.SetCurrentInstructionName("");
        }
        int opcode = ProcessPrefixes();
        if (IsLoggingEnabled())
        {
            _logger.Debug("Before execution: {@OpCode} {@StateString} ", ConvertUtils.ToHex8(opcode),
                stateString);
        }
        if (_state.GetContinueZeroFlagValue() != null && IsStringOpcode(opcode))
        {
            // continueZeroFlag is either true or false if a rep prefix has been encountered
            ProcessRep(opcode);
        }
        else
        {
            // TODO
            //ExecOpcode(opcode);
        }
        if (IsLoggingEnabled())
        {
            String instructionName = _state.GetCurrentInstructionNameWithPrefix();
            _logger.Debug("After execution of {@InstructionName} {@State}", instructionName, _state);
        }
        _state.ClearPrefixes();
        _staticAddressesRecorder.Commit();
        _state.IncCycles();
        HandleExternalInterrupt();
        _state.SetIP(_internalIp);
    }

    private void ProcessRep(int opcode)
    {
        // repeat while zero flag is false for REPNZ (last bit is 0)
        // or while zero flag is true for REPZ (last bit is 1)
        var continueZeroFlagValue = _state.GetContinueZeroFlagValue();
        // For some instructions, zero flag is not to be checked
        bool checkZeroFlag = IsStringOpUpdatingFlags(opcode);
        int cx = _state.GetCX();
        while (cx != 0) {
            // re-set the segment override that may have been cleared. No need to reset ip
            // as string instructions don't modify it and are only one byte.
            // TODO
            //ProcessString(opcode);
            cx = cx - 1;

            if (_logger.IsEnabled(Serilog.Events.LogEventLevel.Verbose)) {
                _logger.Verbose("{@Rep} Loop, {@Cx}, {@If}, {@CheckZeroFlag}, {@ContinueZF}",
                _state.GetCurrentInstructionNameWithPrefix(),
                ConvertUtils.ToHex(cx), _state.GetZeroFlag(), checkZeroFlag, continueZeroFlagValue);
            }
            // Not all the string operations require checking the zero flag...
            if (checkZeroFlag && _state.GetZeroFlag() != continueZeroFlagValue) {
            break;
            }
        }
        _state.SetCX(cx);
    }

    private void Interrupt(int? vectorNumber, bool external)
    {
        if (vectorNumber == null) { return; }
        int targetIP = _memory.GetUint16(4 * vectorNumber.Value);
        int targetCS = _memory.GetUint16(4 * vectorNumber.Value + 2);
        if (_errorOnUninitializedInterruptHandler && targetCS == 0 && targetIP == 0) {
          throw new UnhandledOperationException(_machine,
              $"Int was called but vector was not initialized for vectorNumber={ConvertUtils.ToHex(vectorNumber.Value)}");
        }
        int returnCS = _state.GetCS();
        int returnIP = _internalIp;
        if (IsLoggingEnabled()) {
          _logger.Debug("int {@VectorNumber} handler found in memory, {@SegmentedAddressRepresentation}", ConvertUtils.ToHex(vectorNumber.Value),
              ConvertUtils.ToSegmentedAddressRepresentation(targetCS, targetIP));
        }
        _stack.Push(_state.GetFlags().GetFlagRegister());
        _stack.Push(returnCS);
        _stack.Push(returnIP);
        _state.SetInterruptFlag(false);
        _internalIp = targetIP;
        _state.SetCS(targetCS);
        var recordReturn = true;
        if (external) {
          _functionHandlerInUse = _functionHandlerInExternalInterrupt;
          recordReturn = false;
        }
        _functionHandlerInUse.Icall(CallType.INTERRUPT, targetCS, targetIP, returnCS, returnIP, vectorNumber.Value,
            recordReturn);
    }

    private static bool IsStringOpUpdatingFlags(int stringOpCode) 
        => stringOpCode == 0xA6 // CMPSB
        || stringOpCode == 0xA7 // CMPSW
        || stringOpCode == 0xAE // SCASB
        || stringOpCode == 0xAF; // SCASW
    private int ProcessPrefixes()
    {
        int opcode = NextUint8();
        while (IsPrefix(opcode)) {
            // TODO
            //ProcessPrefix(opcode);
            opcode = NextUint8();
        }
        return opcode;
    }

    private bool IsPrefix(int opcode) => PREFIXES_OPCODES.Contains(opcode);

    private void HandleExternalInterrupt()
    {
        if (_externalInterruptVectorNumber == null || !_state.GetInterruptFlag())
        {
            return;
        }
        if (IsLoggingEnabled())
        {
            _logger.Debug("Interrupted!, {@ExternalInterruptVectorNumber}", _externalInterruptVectorNumber);
        }
        Interrupt(_externalInterruptVectorNumber, true);
        _externalInterruptVectorNumber = null;
    }

    private bool IsStringOpcode(int opcode)
    {
        return STRING_OPCODES.Contains(opcode);
    }

    internal void FarRet(int v)
    {
        throw new NotImplementedException();
    }



    internal StaticAddressesRecorder GetStaticAddressesRecorder()
    {
        throw new NotImplementedException();
    }

    internal void InterruptRet()
    {
        throw new NotImplementedException();
    }

    internal void NearRet(int v)
    {
        throw new NotImplementedException();
    }

    public byte NextUint8()
    {
        var res = _memory.GetUint8(GetInternalIpPhysicalAddress());
        _internalIp++;
        return res;
    }

    public ushort NextUint16()
    {
        var res = _memory.GetUint16(GetInternalIpPhysicalAddress());
        _internalIp += 2;
        return res;
    }

    private int GetInternalIpPhysicalAddress()
    {
        return MemoryUtils.ToPhysicalAddress(_state.GetCS(), _internalIp);
    }
}
